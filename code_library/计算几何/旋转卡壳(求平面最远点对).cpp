/***********************************************
POJ 2187 旋转卡壳(平面最远点对)

直接通过找对踵点来实现旋转卡壳算法的代码会相当冗长
。这里逆向思考，如果qa，qb是凸包上最远两点，必然可
以分别过qa，qb画出一对平行线。通过旋转这对平行线，
我们可以让它和凸包上的一条边重合，可以注意到，qa是
凸包上离p和qb所在直线最远的点。于是我们的思路就是
枚举凸包上的所有边，对每一条边找出凸包上离该边最远
的顶点，计算这个顶点到该边两个端点的距离，并记录最
大的值。直观上这是一个O (n ^ 2)的算法，和直接枚举
任意两个顶点一样了。但是注意到当我们逆时针枚举边的
时候，最远点的变化也是逆时针的，这样就可以不用从头
计算最远点，而可以紧接着上一次的最远点继续计算。于
是我们得到了O (n)的算法
************************************************
@接口: int RotatingCalipers ()
@功能: 求解平面最远点对的距离(平方距离)
@时间复杂度: O (n)
************************************************/

//pp逆时针(important)存储凸包点集，下标为0~len-1
Point pp[maxn];
int len;

int RotatingCalipers ()
{
	int res = 0, cur = 1;
	Point t;
	for (int i = 0; i < len; i++)
	{
		t = pp[i] - pp[(i+1)%len];
		while ((t ^ (pp[(cur+1)%len] - pp[cur])) < 0)
			cur = (cur + 1) % len;
		res = max (res, max (Dist2 (pp[i], pp[cur]), Dist2 (pp[(i+1)%len], pp[(cur+1)%len])));
	}
	return res;
}
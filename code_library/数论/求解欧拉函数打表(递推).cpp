/***********************************************
适用于要频繁求解欧拉函数值的情况，但是由于内存大小
的限制，所以不能求解太大的值,范围是[1, maxn - 1]
************************************************
@接口: void GetEuler ()
@时间复杂度: O (n * log (n))
************************************************/


//注意此时确实只有奇数才能满足euler[i] == i的情况，进而修改函数值，所以筛法时只需要判断奇数这没错
//但是欧拉筛法有一条隐藏的重要性质：每次循环判断完之后(修改或者没修改)，此时的euler[i]的值已经求出来了
//则可以依据这种性质从小到大递推一些涉及欧拉函数的值(比如：UVA11426 递推求解两重gcd问题)

long long euler[maxn+10];

void GetEuler ()
{
    for (long long i = 0; i < maxn; i++)
        euler[i] = i;

    for (long long i = 2; i < maxn; i += 2)
        euler[i] >>= 1;

    for (long long i = 3; i < maxn; i += 2)
    {
        if (euler[i] == i)
        {
            for (long long j = i; j < maxn; j += i)
                euler[j] = euler[j] - euler[j] / i;
        }
    }
}

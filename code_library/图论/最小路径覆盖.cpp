/***********************************************
最小路径覆盖定义：在有向图中找一些路径，使之覆盖
了图中的所有顶点，就是任意一个顶点都跟那些路径中
的某一条相关联，且任何一个顶点有且只有一条路径与
之关联，一个单独的顶点是一条路径。最小路径覆盖就
是最少的路径覆盖数

求法：最小路径覆盖数=顶点数-最大匹配数，所以需要
构造二分图来跑最大匹配


最小路径覆盖与最小边覆盖的区别
最小路径覆盖和最小边覆盖不同，不要求给的图是二分
图，而是要求是的有向图，不能有环，然后根据原图构
造二分图，构造方法是将点一分为二（拆点），v分为
v*和v**然后如v*和u**有边，那么就在v*和u**之间连
一条边。然后最小路径覆盖是n-m，n为原图的点的个数
，m为新造二分图的最大匹配。证明也特别简单，根据
定义最小路径覆盖里要求同一个点只可以属于一条路径
，即路径是不可以开岔的，如果在二分图里选两条有公
共点的边那么反应在原图上就是路径有岔路，那么就不
符合匹配的定义了，所以二分图里选的边必须是无公共
交点的，这就转化到最大匹配了。
************************************************
@接口: void Init ()
@功能: 初始化邻接矩阵
@时间复杂度: O (n ^ 2)

@接口: int dfs (int u)
@功能: 进行dfs增广
@时间复杂度:
@u: 表示一个非饱和点

@接口: long long MaxMatch ()
@功能: 依次查找非饱和点进行匹配尝试
@时间复杂度: O (n ^ 3)
************************************************/

//分别表示邻接矩阵和顶点的访问标志
int edge[maxn][maxn], vis[maxn];
int cx[maxn], cy[maxn], cxlen, cylen;//cx[i]表示集合cx中与i匹配的cy集合中的节点和集合中点的个数

void Init ()//初始化邻接矩阵
{
    for (int i = 1; i < maxn; i++)
        for (int j = 1; j < maxn; j++)
            edge[i][j] = INF;
}

//进行dfs增广
int dfs (int u)
{
    for (int v = 1; v <= cylen; v++)
        if (edge[u][v] < INF && !vis[v])
        {
            vis[v] = 1;
            if (cy[v] == -1 || dfs (cy[v]))
            {
                cy[v] = u;
                cx[u] = v;
                return 1;
            }
        } 
    return 0;
}

//数组下标从1开始
long long MaxMatch ()
{
    long long res = 0;
    memset (cx, -1, sizeof (cx));//初始化集合cx
    memset (cy, -1, sizeof (cy));//初始化集合cy
    for (int i = 1; i <= cxlen; i++)
        if (cx[i] == -1)
        {
            memset (vis, 0, sizeof (vis));
            res += dfs (i);
        }
    return res;
}
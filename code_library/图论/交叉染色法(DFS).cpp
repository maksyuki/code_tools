/***********************************************
判定二分图：
交叉染色法(DFS)是一种判定二分图的常用方法。初始化
所有顶点为无色(颜色0)状态，用DFS遍历一个图G的同时
，顺便对顶点染色(只染1、-1色)。注意遍历过的顶点还
可以再遍历重新上色。遍历到某个时候在对顶点t染色时
，发现边(s,t)的另一个结点s已染色，且s的颜色与当前
正要对t染的颜色相同，那么图G必定不是二分图。
可以想象二分图就像是河的两岸有两排顶点，每染色一
次则过河一次，那么相同颜色的顶点必定在同一侧。一
旦出现异侧有相同颜色的顶点，就可以说明图G不是二分
图了

判定奇圈：
(1)如果一个双连通分量内(连通图)的某些顶点在一个奇
圈中(即双连通分量(连通图)含有奇圈)，那么这个双连
通分量(连通图)的其他顶点也在某个奇圈中

(2)如果一个双连通分量(连通图)含有奇圈，则它必定不
是一个二分图。反过来也成立，这是一个充要条件。所
以若判定当前双连通分量(连通图)不是二分图(含有同颜
色的异侧顶点)，则这个图中存在奇圈
************************************************
@接口: bool CrossColor (int u, int col)
@功能: 判定二分图或者是判定奇圈
@时间复杂度: O (n)
@u: 当前节点
@col: 当前节点将要被染色的值(1或者是-1)
************************************************/

//color[i]表示顶点i被染的颜色，初始化为0，使用1和-1两个值来交叉染色，part[i]表示当前节点是否在同一个双连通分量中，初始化为0
int color[maxn], part[maxn];

bool CrossColor (int u, int col)
{
	color[u] = col;
	for (int v = 1; v <= n; v++)
		if (g[u][v] && part[v])
		{
			if (color[v] == 0 && CrossColor (v, -col)) return 1;
			if (color[v] == col) return 1;
		}
	return 0;
}

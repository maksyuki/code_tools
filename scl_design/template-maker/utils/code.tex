\section{å›¾è®º}
\subsection{kçŸ­è·¯(Dijkstra+é‚»æ¥è¡¨+å †ä¼˜åŒ–)}
\begin{lstlisting}[language=C++]
/***********************************************
ä»¥ POJ 2449 ä¸ºä¾‹

æ±‚è§£è¿‡ç¨‹ ï¼š
 1. å°†å›¾åå‘ï¼Œç”¨ dijstra + heap æ±‚å‡º t åˆ°æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·ç¦»
ï¼Œç›®çš„æ˜¯æ±‚æ‰€æœ‰ç‚¹åˆ°ç‚¹ t çš„æœ€çŸ­è·¯ï¼Œç”¨ dis[i] è¡¨ç¤º i åˆ° t çš„æœ€
çŸ­è·¯ï¼Œå…¶å®è¿™å°±æ˜¯ A* çš„å¯å‘å‡½æ•°ï¼Œæ˜¾ç„¶ ï¼šh(n) <= n åˆ° t çš„å®
é™…ä»£ä»·
 2. å®šä¹‰ä¼°ä»·å‡½æ•°ã€‚æˆ‘ä»¬å®šä¹‰ g(n) ä¸ºä» s åˆ° n æ‰€èŠ±è´¹çš„ä»£ä»·ï¼Œ h(
n) ä¸º dis[n] ï¼Œæ˜¾ç„¶è¿™ç¬¦åˆ A* ç®—æ³•çš„è¦æ±‚
 3. åˆå§‹åŒ–çŠ¶æ€ã€‚çŠ¶æ€ä¸­å­˜æ”¾å½“å‰åˆ°è¾¾çš„ç‚¹ i , fi , gi ã€‚æ˜¾ç„¶ï¼Œ
 fi = gi + dis[i] ã€‚åˆå§‹çŠ¶æ€ä¸º (0, S, dis[S],) ï¼Œå­˜å…¥ä¼˜å…ˆ
çº§é˜Ÿåˆ—ä¸­ã€‚
 4. çŠ¶æ€è½¬ç§»ã€‚å‡è®¾å½“å‰çŠ¶æ€æ‰€åœ¨çš„ç‚¹ u ç›¸é‚»çš„ç‚¹ v ï¼Œæˆ‘ä»¬å¯ä»¥
å¾—åˆ°è½¬æ¢ï¼š (gu, u, fu) --> (gu + w[u][v], v, fu + w[u][v]) ã€‚
 5. ç»ˆæ­¢æ¡ä»¶ã€‚æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šå…¥é˜Ÿåˆ— K æ¬¡ï¼Œå½“ t å‡ºé˜Ÿåˆ— K æ¬¡æ—¶ï¼Œå³
æ‰¾åˆ°è§£ã€‚
************************************************
@ æ¥å£: void Dij (int s)
@ åŠŸèƒ½: æ±‚è§£ä» s å¼€å§‹çš„æœ€çŸ­è·¯
@ æ—¶é—´å¤æ‚åº¦: O (nlogn)
@s: æºç‚¹

@ æ¥å£: int A_star (int s, int k)
@ åŠŸèƒ½: æ±‚è§£ä» s å¼€å§‹çš„ç¬¬kå°å€¼
@ æ—¶é—´å¤æ‚åº¦: O (nk)
@s: æºç‚¹
@k: è¡¨ç¤ºè¦æ±‚è§£ç¬¬ k å°çš„å€¼
************************************************/

#pragma comment(linker, "/STACK:102400000,102400000")
#include <set>
#include <bitset>
#include <list>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <string>
#include <vector>
#include <ios>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <utility>
#include <complex>
#include <numeric>
#include <functional>
#include <cmath>
#include <ctime>
#include <climits>
#include <cstdarg>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <cassert>
using namespace std;

#define CFF freopen ("aaa.txt", "r", stdin)
#define CPPFF ifstream cin ("aaa.txt")
#define DB(ccc) cout << #ccc << " = " << ccc << endl
#define PB push_back
#define MP(A, B) make_pair(A, B)

typedef long long LL;
typedef unsigned long long ULL;
typedef double DB;
typedef pair <int, int> PII;
typedef pair <int, bool> PIB;

const int INF = 0x7F7F7F7F;
const int MOD = 1e9 + 7;
const double EPS = 1e-10;
const double PI = 2 * acos (0.0);
const int maxn = 1000 + 66;

int n, m, dis[maxn], cnt[maxn];
vector <PII> edge[maxn], g[maxn];

struct Node
{
    int g, v, f;
    Node () {}
    Node (int gg, int vv, int ff) : g (gg), v (vv), f (ff) {}
    bool operator < (const Node &a) const
    {
        return f > a.f;
    }
};

void Dij (int s)
{
    fill (dis, dis + maxn, INF);
    dis[s] = 0;
    priority_queue <PII, vector <PII>, greater <PII> > qu;
    qu.push (PII (0, s));
    while (!qu.empty())
    {
        PII tt = qu.top (); qu.pop ();
        int ta = tt.second, tb = tt.first;
        if (dis[ta] < tb) continue;
        for (int i = 0; i < edge[ta].size (); i++)
        {
            PII v = edge[ta][i];
            if (v.first != s && dis[v.first] > v.second + dis[ta])
            {
                dis[v.first] = v.second + dis[ta];
                qu.push (PII (dis[v.first], v.first));
            }
        }
    }
}

int A_star (int s, int k)
{
    if (dis[s] == INF) return -1;
    priority_queue <Node> qu;
    qu.push (Node (0, s, dis[s]));
    Node nxt = Node (0, 0, 0);
    while (!qu.empty ())
    {
        Node tt = qu.top (); qu.pop ();
        cnt[tt.v]++;
        if (cnt[tt.v] > k) continue;
        if (cnt[tt.v] == k) return tt.f;
        for (int i = 0; i < g[tt.v].size (); i++)
        {
            PII vv = g[tt.v][i];
            nxt.g = tt.g + vv.second;
            nxt.v = vv.first;
            nxt.f = nxt.g + dis[vv.first];
            qu.push (nxt);
        }
    }    
    return -1;
    i--;
}

int main()
{
    //CFF;
    //CPPFF;
    while (scanf ("%d%d", &n, &m) != EOF)
    {
        for (int i = 0; i < maxn; i++)
            edge[i].clear (), g[i].clear ();
        memset (cnt, 0, sizeof (cnt));
        for (int i = 1; i <= m; i++)
        {
            int u, v, w;
            scanf ("%d%d%d", &u, &v, &w);
            edge[v].push_back (PII (u, w));
            g[u].push_back (PII (v, w));
        }
        int s, e, k;
        scanf ("%d%d%d", &s, &e, &k);
        if (s == e) k++;
        Dij (e);
        printf ("%d\n", A_star (s, k));
    }
    return 0;
}
\end{lstlisting}
\subsection{äºŒåˆ†å›¾æœ€å¤§åŒ¹é…(åŒˆç‰™åˆ©+dfså¢å¹¿)}
\begin{lstlisting}[language=C++]
/***********************************************
 Ê¹ÓÃ dfs ½øĞĞÔö¹ã£¬ÊÊÓÃÓÚ³íÃÜÍ¼ 
************************************************
@½Ó¿Ú: void Init ()
@¹¦ÄÜ: ³õÊ¼»¯ÁÚ½Ó¾ØÕó
@Ê±¼ä¸´ÔÓ¶È: O (n ^ 2)

@½Ó¿Ú: int dfs (int u)
@¹¦ÄÜ: ½øĞĞdfsÔö¹ã
@Ê±¼ä¸´ÔÓ¶È:
@u: ±íÊ¾Ò»¸ö·Ç±¥ºÍµã

@½Ó¿Ú: long long MaxMatch ()
@¹¦ÄÜ: ÒÀ´Î²éÕÒ·Ç±¥ºÍµã½øĞĞÆ¥Åä³¢ÊÔ
@Ê±¼ä¸´ÔÓ¶È: O (n ^ 3)
************************************************/

//·Ö±ğ±íÊ¾ÁÚ½Ó¾ØÕóºÍ¶¥µãµÄ·ÃÎÊ±êÖ¾
int edge[maxn][maxn], vis[maxn];
int cx[maxn], cy[maxn], cxlen, cylen;//cx[i]±íÊ¾¼¯ºÏcxÖĞÓëiÆ¥ÅäµÄcy¼¯ºÏÖĞµÄ½ÚµãºÍ¼¯ºÏÖĞµãµÄ¸öÊı

void Init ()//³õÊ¼»¯ÁÚ½Ó¾ØÕó
{
    for (int i = 1; i < maxn; i++)
        for (int j = 1; j < maxn; j++)
            edge[i][j] = INF;
}

//½øĞĞdfsÔö¹ã
int dfs (int u)
{
    for (int v = 1; v <= cylen; v++)
        if (edge[u][v] < INF && !vis[v])
        {
            vis[v] = 1;
            if (cy[v] == -1 || dfs (cy[v]))
            {
                cy[v] = u;
                cx[u] = v;
                return 1;
            }
        } 
    return 0;
}

//Êı×éÏÂ±ê´Ó1¿ªÊ¼
long long MaxMatch ()
{
    long long res = 0;
    memset (cx, -1, sizeof (cx));//³õÊ¼»¯¼¯ºÏcx
    memset (cy, -1, sizeof (cy));//³õÊ¼»¯¼¯ºÏcy
    for (int i = 1; i <= cxlen; i++)
        if (cx[i] == -1)
        {
            memset (vis, 0, sizeof (vis));
            res += dfs (i);
        }
    return res;
}
\end{lstlisting}
\subsection{äºŒåˆ†å›¾æœ€å¤§åŒ¹é…(ç½‘ç»œæµæ€æƒ³)}
\begin{lstlisting}[language=C++]
/***********************************************
Ê¹ÓÃdfs½øĞĞÔö¹ã£¬ÊÊÓÃÓÚ³íÃÜÍ¼
×¢Òâ£ºÕâ¸öËã·¨µÄË¼Ïë·Ç³£ÀàËÆÓÚĞÙÑÀÀûËã·¨£¬ĞèÒªºÃ
ºÃ×Ü½áË¼¿¼
************************************************
@½Ó¿Ú: int dfs (int u)
@¹¦ÄÜ: ½øĞĞdfsÔö¹ã
@Ê±¼ä¸´ÔÓ¶È:
@u: ±íÊ¾Ò»¸ö·Ç±¥ºÍµã

@½Ó¿Ú: int MaxMatch ()
@¹¦ÄÜ: ÒÀ´Î²éÕÒ·Ç±¥ºÍµã½øĞĞÆ¥Åä³¢ÊÔ
@Ê±¼ä¸´ÔÓ¶È: O (n ^ 3)
************************************************/

//·Ö±ğ±íÊ¾¶¥µãµÄÆ¥ÅäÇé¿öºÍ¶¥µãµÄ·ÃÎÊ±êÖ¾
int match[maxn], vis[maxn];
vector <int> g[maxn];//Ê¹ÓÃÁÚ½Ó±í´æÍ¼

int dfs (int u)
{
	vis[u] = true;
	for (int i = 0; i < g[u].size (); i++)
	{
		int v = g[u][i], t = match[v];
		if (t < 0 || (!vis[t] && dfs (t)))
		{
			match[u] = v;
			match[v] = u;
			return 1; 
		}
	}
	return 0;
}

int maxmatch ()
{
	int res = 0;
	memset (match, -1, sizeof (match));
	for (int i = 0; i < n; i++)
		if (match[i] == -1)
		{
			memset (vis, 0, sizeof (vis));
			res += dfs (i);
		}
	return res;
}
\end{lstlisting}
\subsection{äº¤å‰æŸ“è‰²æ³•(DFS)}
\begin{lstlisting}[language=C++]
/***********************************************
åˆ¤å®šäºŒåˆ†å›¾ï¼š
äº¤å‰æŸ“è‰²æ³•(DFS)æ˜¯ä¸€ç§åˆ¤å®šäºŒåˆ†å›¾çš„å¸¸ç”¨æ–¹æ³•ã€‚åˆå§‹åŒ–
æ‰€æœ‰é¡¶ç‚¹ä¸ºæ— è‰²(é¢œè‰²0)çŠ¶æ€ï¼Œç”¨DFSéå†ä¸€ä¸ªå›¾Gçš„åŒæ—¶
ï¼Œé¡ºä¾¿å¯¹é¡¶ç‚¹æŸ“è‰²(åªæŸ“1ã€-1è‰²)ã€‚æ³¨æ„éå†è¿‡çš„é¡¶ç‚¹è¿˜
å¯ä»¥å†éå†é‡æ–°ä¸Šè‰²ã€‚éå†åˆ°æŸä¸ªæ—¶å€™åœ¨å¯¹é¡¶ç‚¹tæŸ“è‰²æ—¶
ï¼Œå‘ç°è¾¹(s,t)çš„å¦ä¸€ä¸ªç»“ç‚¹så·²æŸ“è‰²ï¼Œä¸”sçš„é¢œè‰²ä¸å½“å‰
æ­£è¦å¯¹tæŸ“çš„é¢œè‰²ç›¸åŒï¼Œé‚£ä¹ˆå›¾Gå¿…å®šä¸æ˜¯äºŒåˆ†å›¾ã€‚
å¯ä»¥æƒ³è±¡äºŒåˆ†å›¾å°±åƒæ˜¯æ²³çš„ä¸¤å²¸æœ‰ä¸¤æ’é¡¶ç‚¹ï¼Œæ¯æŸ“è‰²ä¸€
æ¬¡åˆ™è¿‡æ²³ä¸€æ¬¡ï¼Œé‚£ä¹ˆç›¸åŒé¢œè‰²çš„é¡¶ç‚¹å¿…å®šåœ¨åŒä¸€ä¾§ã€‚ä¸€
æ—¦å‡ºç°å¼‚ä¾§æœ‰ç›¸åŒé¢œè‰²çš„é¡¶ç‚¹ï¼Œå°±å¯ä»¥è¯´æ˜å›¾Gä¸æ˜¯äºŒåˆ†
å›¾äº†

åˆ¤å®šå¥‡åœˆï¼š
(1)å¦‚æœä¸€ä¸ªåŒè¿é€šåˆ†é‡å†…(è¿é€šå›¾)çš„æŸäº›é¡¶ç‚¹åœ¨ä¸€ä¸ªå¥‡
åœˆä¸­(å³åŒè¿é€šåˆ†é‡(è¿é€šå›¾)å«æœ‰å¥‡åœˆ)ï¼Œé‚£ä¹ˆè¿™ä¸ªåŒè¿
é€šåˆ†é‡(è¿é€šå›¾)çš„å…¶ä»–é¡¶ç‚¹ä¹Ÿåœ¨æŸä¸ªå¥‡åœˆä¸­

(2)å¦‚æœä¸€ä¸ªåŒè¿é€šåˆ†é‡(è¿é€šå›¾)å«æœ‰å¥‡åœˆï¼Œåˆ™å®ƒå¿…å®šä¸
æ˜¯ä¸€ä¸ªäºŒåˆ†å›¾ã€‚åè¿‡æ¥ä¹Ÿæˆç«‹ï¼Œè¿™æ˜¯ä¸€ä¸ªå……è¦æ¡ä»¶ã€‚æ‰€
ä»¥è‹¥åˆ¤å®šå½“å‰åŒè¿é€šåˆ†é‡(è¿é€šå›¾)ä¸æ˜¯äºŒåˆ†å›¾(å«æœ‰åŒé¢œ
è‰²çš„å¼‚ä¾§é¡¶ç‚¹)ï¼Œåˆ™è¿™ä¸ªå›¾ä¸­å­˜åœ¨å¥‡åœˆ
************************************************
@æ¥å£: bool CrossColor (int u, int col)
@åŠŸèƒ½: åˆ¤å®šäºŒåˆ†å›¾æˆ–è€…æ˜¯åˆ¤å®šå¥‡åœˆ
@æ—¶é—´å¤æ‚åº¦: O (n)
@u: å½“å‰èŠ‚ç‚¹
@col: å½“å‰èŠ‚ç‚¹å°†è¦è¢«æŸ“è‰²çš„å€¼(1æˆ–è€…æ˜¯-1)
************************************************/

//color[i]è¡¨ç¤ºé¡¶ç‚¹iè¢«æŸ“çš„é¢œè‰²ï¼Œåˆå§‹åŒ–ä¸º0ï¼Œä½¿ç”¨1å’Œ-1ä¸¤ä¸ªå€¼æ¥äº¤å‰æŸ“è‰²ï¼Œpart[i]è¡¨ç¤ºå½“å‰èŠ‚ç‚¹æ˜¯å¦åœ¨åŒä¸€ä¸ªåŒè¿é€šåˆ†é‡ä¸­ï¼Œåˆå§‹åŒ–ä¸º0
int color[maxn], part[maxn];

bool CrossColor (int u, int col)
{
	color[u] = col;
	for (int v = 1; v <= n; v++)
		if (g[u][v] && part[v])
		{
			if (color[v] == 0 && CrossColor (v, -col)) return 1;
			if (color[v] == col) return 1;
		}
	return 0;
}
\end{lstlisting}
\subsection{å…¨æºæœ€çŸ­è·¯å¾„(Floyd+é‚»æ¥çŸ©é˜µ)}
\begin{lstlisting}[language=C++]
/***********************************************
ÇóÈ«Ô´×î¶ÌÂ·¾¶£¬¿ÉÒÔÊ¹ÓÃÁÚ½Ó¾ØÕó»òÕßÊÇÁÚ½Ó±íÀ´³õ
Ê¼»¯×î¶Ì¾àÀëÊı×é
************************************************
@½Ó¿Ú: void floyd ()
@¹¦ÄÜ: ÇóÈ«Ô´×î¶ÌÂ·¾¶
@Ê±¼ä¸´ÔÓ¶È: O (n^3)
************************************************/

//·Ö±ğ±íÊ¾ÁÚ½Ó¾ØÕóºÍ×î¶Ì¾àÀëÊı×é
int edge[maxn][maxn], dis[maxn][maxn];
//·Ö±ğ±íÊ¾¶¥µã¸öÊıºÍ±ßÊı
int n, m;

//³õÊ¼»¯ÁÚ½Ó¾ØÕó
void Init ()
{
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
        {
            if (i == j)
                edge[i][j] = 0;

            else
                edge[i][j] = INF;
        }
}

//Êı×éÏÂ±ê´Ó1¿ªÊ¼
void floyd ()
{
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            dis[i][j] = edge[i][j];

    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
            {
                if (i == k || j == k)
                    continue;

                if (dis[i][k] < INF && dis[k][j] < INF)
                    dis[i][j] = min (dis[i][j], dis[i][k] + dis[k][j]);
            }
}
\end{lstlisting}
\subsection{å•æºæœ€çŸ­è·¯å¾„(Bellman-foed+é‚»æ¥é˜µ)}
\begin{lstlisting}[language=C++]
/***********************************************
************************************************
@½Ó¿Ú: void Init ()
@¹¦ÄÜ:  ³õÊ¼»¯ÁÚ½Ó¾ØÕó
@Ê±¼ä¸´ÔÓ¶È: O (n ^ 2)

@½Ó¿Ú: void Bellman_ford (int s)
@¹¦ÄÜ: Çó½â´Ó¿ªÊ¼µÄµ«Ô´×î¶ÌÂ·
@Ê±¼ä¸´ÔÓ¶È:  O (n ^ 3)
@s: Ô´µã
************************************************/

//·Ö±ğ±íÊ¾½Úµãµ½Ô´µãµÄ×î¶Ì¾àÀë¡¢ÁÚ½Ó¾ØÕóºÍ¶¥µã¸öÊı
int dis[maxn], edge[maxn][maxn], n;

//³õÊ¼»¯ÁÚ½Ó¾ØÕó
void Init ()
{
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
        {
            if (i == j)
                edge[i][j] = 0;

            else
                edge[i][j] = INF;
        }
}

//Êı×éÏÂ±ê´Ó1¿ªÊ¼
void Bellman_ford (int s)
{
    for (int i = 1; i <= n; i++)
        dis[i] = INF;

    dis[s] = 0;
    for (int i = 1; i < n; i++)//µü´ún-1´Î
    {
        for (int j = 1; j <= n; j++)
        {
            if (j != s)
            {
                for (int k = 1; k <= n; k++)
                {
                    if (dis[k] < INF && edge[k][j] < INF && dis[k] + edge[k][j] < dis[j])
                        dis[j] = dis[k] + edge[k][j];
                }
            }
        }
    }
    //ÅĞ¶Ï¸ºÈ¦µÄ»°ĞèÒªÔÙ½øĞĞÒ»´Îµü´ú£¬¿´ÊÇ·ñ´æÔÚÒ»¸öµãvµÄdis[v]»áÔÙ´Î±»ËÉ³Ú
    //Èç¹û´æÔÚ£¬ÔòËµÃ÷Í¼ÖĞ´æÔÚ¸ºÈ¦
}
\end{lstlisting}
\subsection{å•æºæœ€çŸ­è·¯å¾„(Bellman-ford+è¾¹è¡¨)}
\begin{lstlisting}[language=C++]
/***********************************************
Çó½â´ÓÔ´µãµ½ÆäËû½ÚµãµÄ×î¶ÌÂ·£¬×¢ÒâÏÂÃæµÄËã·¨ÊÊÓÃ
ÓÚÎŞÏòÍ¼ºÍÓĞÏòÍ¼£¬Ö»ÊÇ¶ÔÓÚÎŞÏòÍ¼À´ËµÔÚ¹¹Ôì±ß±íÊ±
Í¬Ò»¸ö±ßÒª²åÈëÁ½´Î
************************************************
@½Ó¿Ú: void bellman_ford (int s)
@Ê±¼ä¸´ÔÓ¶È: O (n * m)
@s: Ô´µã
************************************************/

int dis[maxn], path[maxn];

void Bellman_ford (int s)
{
    for (int i = 0; i < n; i++)
    {
        dis[i] = INF;
        path[i] = -1;
    }

    dis[s] = 0;
    for (int i = 1; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if (dis[edge[j].u] < INF && dis[edge[j].v] > dis[edge[j].u] + edge[j].w)
            {
                dis[edge[j].v] = dis[edge[j].u] + edge[j].w;
                path[edge[j].v] = edge[j].u;
            }
        }
    }
}
\end{lstlisting}
\subsection{å•æºæœ€çŸ­è·¯å¾„(Dijkstra+é‚»æ¥é˜µ)}
\begin{lstlisting}[language=C++]
/***********************************************
************************************************
@½Ó¿Ú: void Init ()
@¹¦ÄÜ: ³õÊ¼»¯ÁÚ½Ó¾ØÕó
@Ê±¼ä¸´ÔÓ¶È: O (n ^ 2)
@:

@½Ó¿Ú: void Dijkstra (int s)
@¹¦ÄÜ: Çó½â´Ós¿ªÊ¼µÄ×î¶ÌÂ·
@Ê±¼ä¸´ÔÓ¶È: O(n¡­^ 2)
@s: Ô´µã
************************************************/

const int maxn = 1000 + 66;

bool vis[maxn];//±íÊ¾½ÚµãµÄ×î¶ÌÂ·ÊÇ·ñÒÑ¾­µÃµ½
//·Ö±ğ±íÊ¾ÁÚ½Ó¾ØÕó¡¢½Úµã×î¶ÌÂ·µÄ³¤¶ÈºÍ¶¥µãµÄ¸öÊı
int edge[maxn][maxn], dis[maxn], n;

void Init ()
{
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
        {
            if (i == j) edge[i][j] = 0;
            else edge[i][j] = INF;
        }
}

void Dijkstra (int s)
{
    memset (vis, false, sizeof (vis));;
    vis[s] = true;
    for (int i = 1; i <= n; i++)//³õÊ¼»¯Ô´µãÏàÁÚ½ÓµÄ½ÚµãµÄ×î¶Ì¾àÀë
        dis[i] = edge[s][i];

    dis[s] = 0;//Ô´µãµ½×Ô¼ºµÄ×î¶ÌÂ·ÊÇ0£¬Ê®·ÖÖØÒª!!!
    for (int i = 2; i <= n; i++)
    {
        int minval = INF, minpos = s;
        for (int j = 1; j <= n; j++)//±éÀú½«»¹Î´È·¶¨×î¶ÌÂ·µÄ½ÚµãÖĞ¾ßÓĞ×îĞ¡¾àÀëµÄµÄ½ÚµãÕÒµ½
            if (j != s && !vis[j] && minval > dis[j])
            {
                minval = dis[j];
                minpos = j;
            }

        vis[minpos] = true;//·ÃÎÊ¸Ã½Úµã
        for (int j = 1; j <= n; j++)//¸üĞÂÓÉÓÚminpos½ÚµãÈ·¶¨×î¶ÌÂ·Ö®ºóµ¼ÖÂµÄ×îĞ¡¾àÀë±ä»¯
            if (j != s && !vis[j] && edge[minpos][j] < INF && edge[minpos][j] + dis[minpos] < dis[j])
                dis[j] = edge[minpos][j] + dis[minpos];
    }
}
\end{lstlisting}
\subsection{å•æºæœ€çŸ­è·¯å¾„(Dijkstra+é‚»æ¥é˜µ+å †ä¼˜åŒ–) }
\begin{lstlisting}[language=C++]
/***********************************************
************************************************
@½Ó¿Ú: void Init ()
@¹¦ÄÜ: ³õÊ¼»¯ÁÚ½Ó¾ØÕó
@Ê±¼ä¸´ÔÓ¶È: O (n ^ 2)
@:

@½Ó¿Ú: void Dijkstra (int s)
@¹¦ÄÜ: Çó½â´Ós¿ªÊ¼µÄ×î¶ÌÂ·
@Ê±¼ä¸´ÔÓ¶È: O(nlogn)
@s: Ô´µã
************************************************/
typedef pair <int, int> PII;

const int maxn = 1000 + 66;
//·Ö±ğ±íÊ¾ÁÚ½Ó¾ØÕó¡¢½Úµã×î¶ÌÂ·µÄ³¤¶ÈºÍ¶¥µãµÄ¸öÊı
int edge[maxn][maxn], dis[maxn], n;

void Init ()
{
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
        {
            if (i == j) edge[i][j] = 0;
            else edge[i][j] = INF;
        }
}

void Dijkstra (int s)
{
    fill (dis, dis + maxn, INF);
    dis[s] = 0;//Ô´µãµ½×Ô¼ºµÄ×î¶ÌÂ·ÊÇ0£¬Ê®·ÖÖØÒª!!!
    priority_queue <PII, vector <PII>, greater <PII> > qu;
    qu.push (PII (0, s));
    while (!qu.empty ())
    {
        PII tt = qu.top (); qu.pop ();
        int ta = tt.second, tb = tt.first;
        if (dis[ta] < tb) continue;
        for (int i = 1; i <= n; i++)
            if (i != s && edge[ta][i] < INF && dis[i] > edge[ta][i] + dis[ta])
            {
                dis[i] = edge[ta][i] + dis[ta];
                qu.push (PII (dis[i], i));
            }
    }
}
\end{lstlisting}
\subsection{å•æºæœ€çŸ­è·¯å¾„(SPFA+é‚»æ¥è¡¨)}
\begin{lstlisting}[language=C++]
/***********************************************
SPFAËã·¨ÍÆ¼öÊ¹ÓÃÁÚ½Ó±í×÷Îª´æÍ¼µÄÊı¾İ½á¹¹
************************************************
@½Ó¿Ú: void spfa (int s)
@¹¦ÄÜ: Çó½â´ÓÔ´µãs¿ªÊ¼µÄ×î¶ÌÂ·
@Ê±¼ä¸´ÔÓ¶È: O(k * m)
@s: Ô´µã
************************************************/

//·Ö±ğ±íÊ¾¶¥µãv¡£wºÍÏÂÒ»¸öÁÚ½ÓµÄÎ»ÖÃ
struct Node
{
    int v, w, next;
};

Node edge[maxn*maxn];
int head[maxn], edgelen;//·Ö±ğ±íÊ¾¶¥µãµÄ±íÍ·½ÚµãºÍ±ßµÄÊıÁ¿

//½«ËùÓĞµÄÊı×é¾ù³õÊ¼»¯Îª-1
void Init ()
{
    memset (head, -1, sizeof (head));
    memset (edge, -1, sizeof (edge));
    edgelen = 0;
}

//Ê¹ÓÃÍ·²å·¨¹¹½¨
void AddEdge (int u, int v, int w)
{
    edge[edgelen].v = v;
    edge[edgelen].w = w;
    edge[edgelen].next = head[u];
    head[u] = edgelen++;
}

//·Ö±ğ±íÊ¾Ô´µãµ½ÆäËû¶¥µãµÄ×î¶Ì¾àÀë¡¢¶¥µãÊÇ·ñÔÚ¶ÓÁĞÖĞµÄÅĞ¶ÏÊı×é¡¢¶¥µãÈë¶ÓÁĞµÄ´ÎÊıºÍ¶¥µã¸öÊı
int dis[maxn], inq[maxn], cnt[maxn];
int n;

//±íÊ¾ÊÇ·ñ´æÔÚ¸ºÈ¨Öµ»ØÂ·£¬true±íÊ¾²»´æÔÚ£¬false±íÊ¾´æÔÚ
bool is_valid;

//Êı×éÏÂ±ê´Ó1¿ªÊ¼
void spfa (int s)
{
    for (int i = 1; i <= n; i++)//³õÊ¼»¯disÊı×éºÍinqÊı×é
    {
        dis[i] = INF;
        inq[i] = cnt[i] = 0;
    }

    dis[s] = 0;//½«Ô´µãµÄdisÊı×éÖµ³õÊ¼»¯Îª0£¬ÖØÒª£¡£¡
    is_valid = true;//³õÊ¼»¯±ê¼Ç
    queue <int> qu;
    qu.push (s);
    inq[s]++;//½«Ô´µã±êÖ¾ÎªÔÚ¶ÓÁĞÖĞ
    cnt[s]++;
    while (!qu.empty ())
    {
        int tt = qu.front(); qu.pop (); inq[tt]--;

        if (cnt[tt] > n)
        {
            is_valid = false;
            return ;
        }

        int pa = head[tt];
        while (pa != -1)
        {
            int pb = edge[pa].v;
            if (dis[tt] < INF && dis[pb] > dis[tt] + edge[pa].w)//ËÉ³Ú²Ù×÷
            {
                dis[pb] = dis[tt] + edge[pa].w;
                if (!inq[pb])//Èç¹û±»ËÉ³ÚµÄ½Úµã²»ÔÚ¶ÓÁĞÖĞ£¬Ôò½«¸Ã½ÚÈë¶Ó
                {
                    qu.push (pb);
                    inq[pb]++;
                    cnt[pb]++;
                }
            }
            pa = edge[pa].next;
        }
    }
}
\end{lstlisting}
\subsection{æœ€å¤§æµ(Dinic)}
\begin{lstlisting}[language=C++]
/***********************************************
Dinicç®—æ³•
************************************************
@æ¥å£: void Init ()
@åŠŸèƒ½: åˆå§‹åŒ–é‚»æ¥è¡¨
@æ—¶é—´å¤æ‚åº¦: O (1)

@æ¥å£: void Bfs (int s, int e)
@åŠŸèƒ½: æ„é€ å±‚æ¬¡ç½‘ç»œ
@æ—¶é—´å¤æ‚åº¦: O (m)
@s: æºç‚¹çš„ä¸‹æ ‡
@e: æ±‡ç‚¹çš„ä¸‹æ ‡

@æ¥å£: int MaxFlow (int s, int e, int n)
@åŠŸèƒ½: è¿”å›ç½‘ç»œæœ€å¤§æµ
@æ—¶é—´å¤æ‚åº¦: (n ^ 2 * m)
@s: æºç‚¹çš„ä¸‹æ ‡
@e: æ±‡ç‚¹çš„ä¸‹æ ‡
@n: é¡¶ç‚¹ä¸ªæ•°
************************************************/

//åˆ†åˆ«è¡¨ç¤ºé‚»æ¥èŠ‚ç‚¹çš„ä¸‹æ ‡ã€é‚»æ¥è¡¨ä¸­ä¸‹ä¸€ä¸ªä½ç½®ã€å½“å‰è¾¹çš„å®¹é‡å’Œæµé‡
struct Node
{
	int to, nxt, c, f;	
};

Node edge[maxn];
int head[maxn], edgelen;
int dep[maxn], cnt[maxn], cur[maxn];//åˆ†åˆ«è¡¨ç¤ºé¡¶ç‚¹çš„å±‚æ¬¡å€¼ã€å±‚æ¬¡å€¼å‡ºç°çš„æ¬¡æ•°å’Œä¸´æ—¶headè¡¨

void Init ()
{
	memset (head, -1, sizeof (head));
	memset (edge, -1, sizeof (edge));
	edgelen = 0;
}

//edgeä»0å¼€å§‹ï¼Œæ‰€ä»¥é¡¶ç‚¹å¯¹ä¸º(0,1)ã€(2,3)...ï¼Œå³ä»»æ„é¡¶ç‚¹å€¼å¯¹1å–å¼‚æˆ–å¾—åˆ°çš„è¿˜æ˜¯é¡¶ç‚¹å¯¹ä¸­çš„æ•°ï¼Œä¿è¯é€†å‘è·¯å¾„è½¬æ¢ä¸ºæ­£å‘è·¯å¾„
void AddEdge (int u, int v, int w, int rw = 0)
{
	edge[edgelen].to = v, edge[edgelen].c = w, edge[edgelen].f = 0;
	edge[edgelen].nxt = head[u], head[u] = edgelen++;
	edge[edgelen].to = u, edge[edgelen].c = rw, edge[edgelen].f = 0;
	edge[edgelen].nxt = head[v], head[v] = edgelen++;
}

//ä»æ±‡ç‚¹eå¼€å§‹åå‘æ„å»ºå±‚æ¬¡è¡¨(å³eçš„depå€¼ä¸º0)
void Bfs (int s, int e)
{
	memset (dep, -1, sizeof (dep));
	memset (cnt, 0, sizeof (cnt));
	dep[e] = 0;
	cnt[dep[e]]++;
	queue <int> qu;
	qu.push (e);
	while (!qu.empty ())
	{
		int u = qu.front (); qu.pop ();
		for (int i = head[u]; i != -1; i = edge[i].nxt)
		{
			int v = edge[i].to;
			if (dep[v] != -1) continue;
			qu.push (v);
			dep[v] = dep[u] + 1;
			cnt[dep[v]]++;
		}
	}
}

int sta[maxn];//æ ˆ

int MaxFlow (int s, int e, int n)
{
	Bfs (s, e);	
	int res = 0, top = 0, u = s;
	memcpy (cur, head, sizeof (head));
	while (dep[s] < n)
	{
		if (u == e)//è‹¥å½“å‰é¡¶ç‚¹ä¸ºæ±‡ç‚¹åˆ™è¡¨ç¤ºæ‰¾åˆ°å¢å¹¿è·¯ï¼Œæ­¤æ—¶å¯»æ‰¾è·¯å¾„ä¸Šæœ€å°å‰©ä½™æµé‡å¹¶ä¿®æ”¹è·¯å¾„ä¸Šçš„æ‰€æœ‰ç‚¹çš„æµé‡å€¼
		{
			int minval = INF, minval_pos = -1;
			for (int i = 0; i < top; i++)
				if (minval > edge[sta[i]].c - edge[sta[i]].f)
				{
					minval = edge[sta[i]].c - edge[sta[i]].f;
					minval_pos = i;
				}
			for (int i = 0; i < top; i++)
			{
				edge[sta[i]].f += minval;
				edge[sta[i]^1].f -= minval;
			}
			res += minval;
			top = minval_pos;
			u = edge[sta[top]^1].to;
		}
		else
		{
			bool is_have = false;//åˆ¤æ–­æ˜¯å¦èƒ½å¤Ÿå‘æ›´ä½å±‚æ¬¡çš„ç‚¹ç§»åŠ¨ï¼Œè‹¥å¯ä»¥åˆ™ç§»åŠ¨
			for (int i = cur[u]; i != -1; i = edge[i].nxt)
			{
				int v = edge[i].to;
				if (edge[i].c - edge[i].f && dep[v] + 1 == dep[u])
				{
					cur[u] = i;
					sta[top++] = cur[u];
					u = v;
					is_have = true;
					break;
				}
			}
			if (is_have) continue;

			int minval = n;//è‹¥ä¸å¯ç§»åŠ¨ï¼Œåˆ™å›é€€ç¦»æºç‚¹æœ€è¿œæ»¡è¶³æ¡ä»¶çš„ç‚¹ç»§ç»­åˆ¤æ–­
			for (int i = head[u]; i != -1; i = edge[i].nxt)
				if (edge[i].c - edge[i].f && dep[edge[i].to] < minval)
				{
					minval = dep[edge[i].to];
					cur[u] = i;
				}
			cnt[dep[u]]--;
			if (!cnt[dep[u]]) return res;//å›é€€ä¹‹åå‘ç°æ‰€æœ‰å±‚æ¬¡å€¼ä¸ºdep[u]çš„é¡¶ç‚¹éƒ½æ²¡æœ‰äº†ï¼Œåˆ™ä¸€å®šä¸ä¼šæœ‰å¢å¹¿è·¯äº†
			dep[u] = minval + 1;
			cnt[dep[u]]++;//è‹¥å±‚æ¬¡å€¼ä¸ºdep[u]çš„é¡¶ç‚¹è¿˜æœ‰ï¼Œåˆ™å°†å½“å‰é¡¶ç‚¹uçš„depå€¼å’Œæ•°é‡cntè¿˜åŸ
			if (u != s) u = edge[sta[--top]^1].to;
		}
	}
	return res;
}
\end{lstlisting}
\subsection{æœ€å¤§æµ(Edmonds-Karp)}
\begin{lstlisting}[language=C++]
/***********************************************
ÒÔPOJ 2173ÎªÀı
************************************************
@½Ó¿Ú: long long Edmonds_Karp (int s, int t)
@¹¦ÄÜ: ·µ»Ø×î´óÁ÷
@Ê±¼ä¸´ÔÓ¶È: O (n * m ^ 2)
@s: Ô´µãµÄÏÂ±ê
@t: »ãµãµÄÏÂ±ê
************************************************/

#include <set>
#include <bitset>
#include <list>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <string>
#include <vector>
#include <ios>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <utility>
#include <complex>
#include <numeric>
#include <functional>
#include <cmath>
#include <ctime>
#include <climits>
#include <cstdarg>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <cassert>
using namespace std;

const int INF = 0x7FFFFFFF;
const int MOD = 7;
const double EPS = 1e-10;
const double PI = 2 * acos (0.0);
const int maxn = 200 + 66;


struct Node
{
	int c, f;//·Ö±ğ±íÊ¾»¡Ö®¼äµÄÈİÁ¿ºÍÁ÷Á¿
};

Node edge[maxn][maxn];
//n±íÊ¾¶¥µãµÄ¸öÊı£¬m±íÊ¾±ßµÄ¸öÊı£¬pre±íÊ¾µ±Ç°½ÚµãµÄÇ°×º½Úµã£¬a±íÊ¾µ±Ç°½ÚµãµÄ¿ÉÔö¹ãÁ¿£¬ÆäÖĞa[i] = 0±íÊ¾
//µ±Ç°½Úµã²»¿ÉÒÔÔö¹ã»òÕßÊÇ»¹Ã»ÓĞ±»·ÃÎÊ
int n, m, pre[maxn], a[maxn];

//ÔÚµ÷ÓÃº¯ÊıÇ°Òª½«Á÷Á¿³õÊ¼»¯³ÉÁãÁ÷!!!
long long Edmonds_Karp (int s, int t)
{
    queue <int> q;
    memset (a, 0, sizeof(a));
    memset (pre, 0, sizeof(pre));
    long long maxflow = 0;

    while (1)
    {
        memset (a, 0, sizeof(a));
        a[s] = INF;//¸³ÖµINF±íÊ¾Ô´µã¿ÉÒÔÂú×ãËùÓĞÁÚ½Ó½ÚµãµÄÁ÷Á¿ĞèÇó
        q.push(s);
        while (!q.empty())
        {
            int tt = q.front(); q.pop();

            for (int i = 1; i <= n; i++)
            if(!a[i] && edge[tt][i].c > edge[tt][i].f)
            {
                pre[i] = tt;
                q.push (i);
                a[i] = a[tt] < edge[tt][i].c - edge[tt][i].f ? a[tt]:edge[tt][i].c - edge[tt][i].f;
            }
        }

        if(a[t] == 0) break;

        for(int i = t; i != s; i = pre[i])
        {
            edge[pre[i]][i].f += a[t];
            edge[i][pre[i]].f -= a[t];
        }

        maxflow += a[t];
    }
    return maxflow;
}


int main()
{
//    ifstream cin ("aaa.txt");

    while (cin >> m >> n)
	{
		memset (edge, 0, sizeof (edge));

        int u, v, w;
        for (int i = 1; i <= m; i++)
        {
            cin >> u >> v >> w;
            edge[u][v].c += w;
        }

        cout << Edmonds_Karp (1, n) << endl;
	}

return 0;
}
\end{lstlisting}
\subsection{æœ€å¤§æµ(Edmonds-Karp)(è‡ªå†™å¾…ä¿®æ”¹)}
\begin{lstlisting}[language=C++]
#include <set>
#include <bitset>
#include <list>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <string>
#include <vector>
#include <ios>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <utility>
#include <complex>
#include <numeric>
#include <functional>
#include <cmath>
#include <ctime>
#include <climits>
#include <cstdarg>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <cassert>
using namespace std;

const int INF = 0x7FFFFFFF;
const int MOD = 7;
const double EPS = 1e-10;
const double PI = 2 * acos (0.0);
const int maxn = 100 + 66;


struct Node
{
	int c, f;//·Ö±ğ±íÊ¾»¡Ö®¼äµÄÈİÁ¿ºÍÁ÷Á¿
};

Node edge[maxn][maxn];
int n, m;
int vis[maxn], pre[maxn], res[maxn][maxn];

void FindAugmentPath (int s, int t)
{
	memset (vis, 0, sizeof (vis));
	memset (res, -1, sizeof (res));
	memset (pre, -1, sizeof (pre));
	pre[s] = INF, vis[s] = 1;
	queue <int> qu;
	qu.push(s);

	while(!qu.empty() && pre[t] == -1)
	{
        int tt = qu.front(); qu.pop ();
        for (int i = 0; i <= n + 1; i++)
		{
            if (!vis[i])
			{
                if (edge[tt][i].f < edge[tt][i].c)
				{
					res[tt][i] = edge[tt][i].c - edge[tt][i].f;
					vis[i] = 1, pre[i] = tt, qu.push(i);
				}

				else if (edge[i][tt].f > 0)
				{
					res[tt][i] = edge[i][tt].f;
					vis[i] = 1, pre[i] = tt, qu.push(i);
				}
			}
		}
	}
}

long long GetAugmentFlow (int s, int t)
{
    if (pre[t] == -1)
		return 0;

	int pa = t, pb = INF;
	while (pa != s)
	{
        if (res[pre[pa]][pa] < pb)
			pb = res[pre[pa]][pa];

		pa = pre[pa];
	}

	return pb;
}

void UpDateFlow (int s, int t, int v)
{
	if (pre[t] == -1)
		return ;

    int pa = t;
    while (pa != s)
	{
        if (edge[pre[pa]][pa].c > edge[pre[pa]][pa].f)
			edge[pre[pa]][pa].f += v;

		else if (edge[pa][pre[pa]] .f > 0)
			edge[pre[pa]][pa].f += v;

		pa = pre[pa];
	}
}

long long Ford_Fulkerson (int s, int t)
{
    long long maxflow = 0, tt;
    while (1)
	{
        FindAugmentPath (s, t);
        tt = GetAugmentFlow (s, t);
        maxflow += tt;
        if (tt > 0)
			UpDateFlow (s, t, tt);

		else
			return maxflow;
	}
}

int pig[maxn], last[maxn];

int main()
{
//	ifstream cin ("aaa.txt");

    while (cin >> m >> n)
	{
		memset (edge, 0, sizeof (edge));
        memset (last, 0, sizeof (last));

        for (int i =1;  i <= m; i++)
            cin >> pig[i];

        for (int i = 1; i <= n; i++)
        {
            int tt;
            cin >> tt;
            for (int j = 1; j <= tt; j++)
            {
                int k;
                cin >> k;
                if (!last[k])
                    edge[0][i].c += pig[k];

                else
                    edge[last[k]][i].c = INF;

                last[k] = i;
            }
            cin >> edge[i][n+1].c;
        }

        cout << Ford_Fulkerson (0, n + 1) << endl;
	}

return 0;
}
\end{lstlisting}
\subsection{æœ€å°ç”Ÿæˆæ ‘(Kruskal+è¾¹è¡¨)}
\begin{lstlisting}[language=C++]
/***********************************************
************************************************
@½Ó¿Ú: int UnFind (int val)
@Ê±¼ä¸´ÔÓ¶È: O (n)
@val: ½ÚµãµÄĞòºÅ

@½Ó¿Ú: void kruskal
@Ê±¼ä¸´ÔÓ¶È: O (n)
************************************************/

const int maxn = 1e6+66;

struct Node
{
    int u, v, w;
};

Node a[maxn];
int parent[maxn], n, r;

bool cmp (Node aa, Node bb)
{
	return aa.w < bb.w;
}

int UnFind (int val)
{
	if (parent[val] == val)
		return val;

	return parent[val] = UnFind (parent[val]);
}

long long kruskal ()
{
    long long remain = n, res = 0;
    for (int i = 1; i <= r && remain > 1; i++)
	{
        if (UnFind (a[i].u) != UnFind(a[i].v))
		{
            parent[UnFind(a[i].u)] = UnFind (a[i].v);
            remain--;
            res += a[i].w;
		}
	}

return res;
}
\end{lstlisting}
\subsection{æœ€å°ç”Ÿæˆæ ‘(Prim+é‚»æ¥çŸ©é˜µ)}
\begin{lstlisting}[language=C++]
/***********************************************
************************************************
@½Ó¿Ú: void Init ()
@¹¦ÄÜ: ³õÊ¼»¯ÁÚ½Ó¾ØÕó
@Ê±¼ä¸´ÔÓ¶È: O (n^2)
@:

@½Ó¿Ú: long long Prim (int s)
@¹¦ÄÜ: Çó½â×îĞ¡Éú³ÉÊ÷
@Ê±¼ä¸´ÔÓ¶È: O (n^2)
@s: Ô´µã
************************************************/

const int maxn = 100 + 66;

bool vis[maxn];//±íÊ¾½ÚµãÊÇ·ñÔÚ×îĞ¡Éú³ÉÊ÷ÖĞ
//·Ö±ğ±íÊ¾ÁÚ½Ó¾ØÕó¡¢½Úµã¾àÀë×îĞ¡Éú³ÉÊ÷µÄ¾àÀëºÍ¶¥µãµÄ¸öÊı
int edge[maxn][maxn], dis[maxn], n;

void Init ()
{
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
        {
            if (i == j)
                edge[i][j] = 0;

            else
                edge[i][j] = INF;
        }
}

long long Prim (int s)
{
    memset (vis, false, sizeof (vis));
    long long res = 0;
    vis[s] = true;

    for (int i = 1; i <= n; i++)//³õÊ¼»¯Ô´µãÏàÁÚ½ÓµÄ½ÚµãµÄ×îĞ¡Éú³ÉÊ÷¾àÀë
        dis[i] = edge[s][i];

    for (int i = 2; i <= n; i++)
    {
        int minval = INF, minpos = s;
        for (int j = 1; j <= n; j++)//±éÀú½«»¹Î´ÔÚMSTÖĞ¾ßÓĞ×îĞ¡¾àÀëµÄµÄ½ÚµãÕÒµ½
            if (j != s && !vis[j] && minval > dis[j])
            {
                minval = dis[j];
                minpos = j;
            }

        vis[minpos] = true;//·ÃÎÊ¸Ã½Úµã
        res += minval;//ÀÛ¼Ó±ßÈ¨

        for (int j = 1; j <= n; j++)//¸üĞÂÓÉÓÚminpos½Úµã¼ÓÈëµ½MSTµ¼ÖÂµÄ×îĞ¡¾àÀë±ä»¯
            if (j != s && !vis[j] && edge[minpos][j] < dis[j])
                dis[j] = edge[minpos][j];
    }

    return res;
}
\end{lstlisting}
\subsection{æœ€å°è·¯å¾„è¦†ç›–}
\begin{lstlisting}[language=C++]
/***********************************************
æœ€å°è·¯å¾„è¦†ç›–å®šä¹‰ï¼šåœ¨æœ‰å‘å›¾ä¸­æ‰¾ä¸€äº›è·¯å¾„ï¼Œä½¿ä¹‹è¦†ç›–
äº†å›¾ä¸­çš„æ‰€æœ‰é¡¶ç‚¹ï¼Œå°±æ˜¯ä»»æ„ä¸€ä¸ªé¡¶ç‚¹éƒ½è·Ÿé‚£äº›è·¯å¾„ä¸­
çš„æŸä¸€æ¡ç›¸å…³è”ï¼Œä¸”ä»»ä½•ä¸€ä¸ªé¡¶ç‚¹æœ‰ä¸”åªæœ‰ä¸€æ¡è·¯å¾„ä¸
ä¹‹å…³è”ï¼Œä¸€ä¸ªå•ç‹¬çš„é¡¶ç‚¹æ˜¯ä¸€æ¡è·¯å¾„ã€‚æœ€å°è·¯å¾„è¦†ç›–å°±
æ˜¯æœ€å°‘çš„è·¯å¾„è¦†ç›–æ•°

æ±‚æ³•ï¼šæœ€å°è·¯å¾„è¦†ç›–æ•°=é¡¶ç‚¹æ•°-æœ€å¤§åŒ¹é…æ•°ï¼Œæ‰€ä»¥éœ€è¦
æ„é€ äºŒåˆ†å›¾æ¥è·‘æœ€å¤§åŒ¹é…


æœ€å°è·¯å¾„è¦†ç›–ä¸æœ€å°è¾¹è¦†ç›–çš„åŒºåˆ«
æœ€å°è·¯å¾„è¦†ç›–å’Œæœ€å°è¾¹è¦†ç›–ä¸åŒï¼Œä¸è¦æ±‚ç»™çš„å›¾æ˜¯äºŒåˆ†
å›¾ï¼Œè€Œæ˜¯è¦æ±‚æ˜¯çš„æœ‰å‘å›¾ï¼Œä¸èƒ½æœ‰ç¯ï¼Œç„¶åæ ¹æ®åŸå›¾æ„
é€ äºŒåˆ†å›¾ï¼Œæ„é€ æ–¹æ³•æ˜¯å°†ç‚¹ä¸€åˆ†ä¸ºäºŒï¼ˆæ‹†ç‚¹ï¼‰ï¼Œvåˆ†ä¸º
v*å’Œv**ç„¶åå¦‚v*å’Œu**æœ‰è¾¹ï¼Œé‚£ä¹ˆå°±åœ¨v*å’Œu**ä¹‹é—´è¿
ä¸€æ¡è¾¹ã€‚ç„¶åæœ€å°è·¯å¾„è¦†ç›–æ˜¯n-mï¼Œnä¸ºåŸå›¾çš„ç‚¹çš„ä¸ªæ•°
ï¼Œmä¸ºæ–°é€ äºŒåˆ†å›¾çš„æœ€å¤§åŒ¹é…ã€‚è¯æ˜ä¹Ÿç‰¹åˆ«ç®€å•ï¼Œæ ¹æ®
å®šä¹‰æœ€å°è·¯å¾„è¦†ç›–é‡Œè¦æ±‚åŒä¸€ä¸ªç‚¹åªå¯ä»¥å±äºä¸€æ¡è·¯å¾„
ï¼Œå³è·¯å¾„æ˜¯ä¸å¯ä»¥å¼€å²”çš„ï¼Œå¦‚æœåœ¨äºŒåˆ†å›¾é‡Œé€‰ä¸¤æ¡æœ‰å…¬
å…±ç‚¹çš„è¾¹é‚£ä¹ˆååº”åœ¨åŸå›¾ä¸Šå°±æ˜¯è·¯å¾„æœ‰å²”è·¯ï¼Œé‚£ä¹ˆå°±ä¸
ç¬¦åˆåŒ¹é…çš„å®šä¹‰äº†ï¼Œæ‰€ä»¥äºŒåˆ†å›¾é‡Œé€‰çš„è¾¹å¿…é¡»æ˜¯æ— å…¬å…±
äº¤ç‚¹çš„ï¼Œè¿™å°±è½¬åŒ–åˆ°æœ€å¤§åŒ¹é…äº†ã€‚
************************************************
@æ¥å£: void Init ()
@åŠŸèƒ½: åˆå§‹åŒ–é‚»æ¥çŸ©é˜µ
@æ—¶é—´å¤æ‚åº¦: O (n ^ 2)

@æ¥å£: int dfs (int u)
@åŠŸèƒ½: è¿›è¡Œdfså¢å¹¿
@æ—¶é—´å¤æ‚åº¦:
@u: è¡¨ç¤ºä¸€ä¸ªéé¥±å’Œç‚¹

@æ¥å£: long long MaxMatch ()
@åŠŸèƒ½: ä¾æ¬¡æŸ¥æ‰¾éé¥±å’Œç‚¹è¿›è¡ŒåŒ¹é…å°è¯•
@æ—¶é—´å¤æ‚åº¦: O (n ^ 3)
************************************************/

//åˆ†åˆ«è¡¨ç¤ºé‚»æ¥çŸ©é˜µå’Œé¡¶ç‚¹çš„è®¿é—®æ ‡å¿—
int edge[maxn][maxn], vis[maxn];
int cx[maxn], cy[maxn], cxlen, cylen;//cx[i]è¡¨ç¤ºé›†åˆcxä¸­ä¸iåŒ¹é…çš„cyé›†åˆä¸­çš„èŠ‚ç‚¹å’Œé›†åˆä¸­ç‚¹çš„ä¸ªæ•°

void Init ()//åˆå§‹åŒ–é‚»æ¥çŸ©é˜µ
{
    for (int i = 1; i < maxn; i++)
        for (int j = 1; j < maxn; j++)
            edge[i][j] = INF;
}

//è¿›è¡Œdfså¢å¹¿
int dfs (int u)
{
    for (int v = 1; v <= cylen; v++)
        if (edge[u][v] < INF && !vis[v])
        {
            vis[v] = 1;
            if (cy[v] == -1 || dfs (cy[v]))
            {
                cy[v] = u;
                cx[u] = v;
                return 1;
            }
        } 
    return 0;
}

//æ•°ç»„ä¸‹æ ‡ä»1å¼€å§‹
long long MaxMatch ()
{
    long long res = 0;
    memset (cx, -1, sizeof (cx));//åˆå§‹åŒ–é›†åˆcx
    memset (cy, -1, sizeof (cy));//åˆå§‹åŒ–é›†åˆcy
    for (int i = 1; i <= cxlen; i++)
        if (cx[i] == -1)
        {
            memset (vis, 0, sizeof (vis));
            res += dfs (i);
        }
    return res;
}
\end{lstlisting}
\subsection{æ¬¡çŸ­è·¯(Dijkstra+é‚»æ¥è¡¨+å †ä¼˜åŒ–)}
\begin{lstlisting}[language=C++]
/***********************************************
ÒÔPOJ3255ÎªÀı
************************************************
@½Ó¿Ú:  void Dijkstra (int s)
@¹¦ÄÜ: Çó½â´ÓÔ´µãs¿ªÊ¼µÄ´Î¶ÌÂ·
@Ê±¼ä¸´ÔÓ¶È: O (nlogn)
@s: Ô´µã
************************************************/

#pragma comment(linker, "/STACK:102400000,102400000")
#include <set>
#include <bitset>
#include <list>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <string>
#include <vector>
#include <ios>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <utility>
#include <complex>
#include <numeric>
#include <functional>
#include <cmath>
#include <ctime>
#include <climits>
#include <cstdarg>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <cassert>
using namespace std;

#define CFF freopen ("aaa.txt", "r", stdin)
#define CPPFF ifstream cin ("aaa.txt")
#define	DB(ccc)	cout << #ccc << " = " << ccc << endl
#define PB push_back
#define MP(A, B) make_pair(A, B)

typedef long long LL;
typedef unsigned long long ULL;
typedef double DB;
typedef pair <int, int> PII;
typedef pair <int, bool> PIB;

const int INF = 0x7FFFFFFF;
const int MOD = 1e9 + 7;
const double EPS = 1e-10;
const double PI = 2 * acos (0.0);
const int maxn = 5e3 + 66;

vector <PII> edge[maxn];
int n, dis[maxn][2];//n±íÊ¾½ÚµãµÄ¸öÊı£¬dis[i][0]±íÊ¾´ÓÔ´µãµ½iµÄ×î¶ÌÂ·£¬dis[i][1]±íÊ¾´ÓÔ´µãµ½iµÄ´Î¶ÌÂ·

void Dijkstra (int s)
{
    for (int i = 0; i < maxn; i++)
        for (int j = 0; j < 2; j++)
            dis[i][j] = INF;

    dis[s][0] = 0;//Ô´µãµ½×Ô¼ºµÄ×î¶ÌÂ·ÊÇ0£¬Ê®·ÖÖØÒª!!!
    priority_queue <PII, vector <PII>, greater <PII> > qu;
    qu.push (PII (0, s));
    while (!qu.empty ())
    {
        PII ta = qu.top (); qu.pop ();
        int v1 = ta.second, d1 = ta.first;
        if (dis[v1][1] < d1) continue;
        for (int i = 0; i < edge[v1].size (); i++)
        {
            PII tb = edge[v1][i];
            int v2 = tb.first, w2 = tb.second;
            int d2 = d1 + w2;
            if (dis[v2][0] > d2)
            {
                swap (dis[v2][0], d2);
                qu.push (PII (dis[v2][0], v2));
            }

            if (dis[v2][0] < d2 && dis[v2][1] > d2)
            {
                dis[v2][1] = d2;
                qu.push (PII (dis[v2][1], v2));
            }
        }
    }
}


int main()
{
//    CFF;
    int m;
    while (scanf ("%d %d", &n, &m) != EOF)
    {
        for (int i = 0; i < maxn; i++) edge[i].clear ();

        for (int i = 1; i <= m; i++)
        {
            int u, v, w;
            scanf ("%d %d %d", &u, &v, &w);
            edge[u].PB (PII (v, w));
            edge[v].PB (PII (u, w));
        }

        Dijkstra (1);
        printf ("%d\n", dis[n][1]);
    }
    return 0;
}
\end{lstlisting}
\subsection{æ±‚æ— å‘å›¾å‰²ç‚¹+è¾“å‡ºé‡è¿é€šåˆ†é‡}
\begin{lstlisting}[language=C++]
/***********************************************
ç”¨æ±‚è§£æ— å‘å›¾å‰²ç‚¹çš„Tarjanç®—æ³•æ¥è¾“å‡ºé‡è¿é€šåˆ†é‡(ç‚¹)

æ±‚æ³•ï¼šå»ºç«‹ä¸€ä¸ªæ ˆï¼Œåœ¨dfså‘ä¸‹æœç´¢çš„è¿‡ç¨‹ä¸­ï¼Œæ¯æ‰¾åˆ°ä¸€
ä¸ªç”Ÿæˆæ ‘çš„è¾¹æˆ–è€…æ˜¯å›è¾¹ï¼Œåˆ™è¯¥è¾¹å…¥æ ˆã€‚è‹¥é‡åˆ°ä¸€ä¸ªå‰²ç‚¹
uï¼Œåˆ™å°†è¾¹ä»æ ˆä¸­é€€å‡ºå¹¶è¾“å‡ºï¼Œç›´åˆ°é€€å‡ºè¾¹(u,v)ï¼Œå³é€€å‡º
çš„è¾¹åŠå…¶é‚»æ¥çš„ç‚¹ç»„æˆä¸€ä¸ªé‡è¿é€šåˆ†é‡(ç‚¹)

æ³¨æ„ï¼š
ä¸ºäº†é˜²æ­¢è®¿é—®è¿‡çš„è¾¹é‡å¤å…¥æ ˆï¼Œé¢å¤–å®šä¹‰edge[i][j]==2
è¡¨ç¤ºé¡¶ç‚¹iå’Œjä¹‹é—´æœ‰è¾¹ä¸”å·²ç»éå†è¿‡äº†
************************************************/

#pragma comment(linker, "/STACK:102400000,102400000")
#include <set>
#include <bitset>
#include <list>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <string>
#include <vector>
#include <ios>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <utility>
#include <complex>
#include <numeric>
#include <functional>
#include <cmath>
#include <ctime>
#include <climits>
#include <cstdarg>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <cassert>
using namespace std;

#define CFF freopen ("aaa.txt", "r", stdin)
#define CPPFF ifstream cin ("aaa.txt")
#define	DB(ccc)	cout << #ccc << " = " << ccc << endl
#define PB push_back
#define MP(A, B) make_pair(A, B)

typedef long long LL;
typedef unsigned long long ULL;
typedef double DB;
typedef pair <int, int> PII;
typedef pair <int, bool> PIB;

const int INF = 0x7F7F7F7F;
const int MOD = 1e9 + 7;
const double EPS = 1e-10;
const double PI = 2 * acos (0.0);
const int maxn = 66;

//edge[i][j] == INFè¡¨ç¤ºé¡¶ç‚¹iå’Œjä¹‹é—´æ²¡æœ‰è¾¹ï¼Œä¸”æ²¡æœ‰éå†è¿‡
//edge[i][j] == 1è¡¨ç¤ºé¡¶ç‚¹iå’Œjä¹‹é—´æœ‰è¾¹
//edge[i][j] == 2è¡¨ç¤ºé¡¶ç‚¹iå’Œjä¹‹é—´æœ‰è¾¹ï¼Œä¸”å·²ç»éå†è¿‡äº†
int edge[maxn][maxn], vis[maxn], dfn[maxn], low[maxn];
int n, m, id;
stack <PII> sta;//æ³¨æ„æ¸…ç©º

void Init (int rt)
{
	for (int i = 0; i < maxn; i++)
		for (int j = 0; j < maxn; j++)
			edge[i][j] = INF;

	while (!sta.empty ()) sta.pop ();
	dfn[rt] = low[rt] = id = 1;
	memset (vis, 0, sizeof (vis));
	vis[rt] = 1;
}

void dfs (int u, int par)
{
	for (int v = 1; v <= n; v++)
	{
		if (edge[u][v] == 1)
		{
			sta.push (PII (u, v));
			edge[u][v] = edge[v][u] = 2;
			if (!vis[v])
			{
				vis[v] = 1;
				dfn[v] = low[v] = ++id;
				dfs (v, u);
				low[u] = min (low[u], low[v]);
				if (low[v] >= dfn[u])
				{
					while (!sta.empty ())
					{
						PII temp = sta.top ();
						printf (" %d-%d", temp.first, temp.second);
						sta.pop ();
						if ((temp.first == u && temp.second == v) || (temp.first == v && temp.second == u)) 
							break;
					}
					puts ("");
				}
			}

			else if (v != par)
				low[u] = min (low[u], dfn[v]);
		}	
	}
}

int main()
{
    CFF;
    //CPPFF;
  	while (scanf ("%d%d", &n, &m) != EOF)
	{
		Init (1);
		for (int i = 1; i <= m; i++)
		{
			int u, v;
			scanf ("%d%d", &u, &v);
			edge[u][v] = edge[v][u] = 1;
		}

		dfs (1, -1);
	}
    return 0;
}
\end{lstlisting}
\subsection{æ±‚æ— å‘å›¾å‰²è¾¹}
\begin{lstlisting}[language=C++]
/***********************************************
ä»¥ZOJ 2588ä¸ºä¾‹ Tarjanç®—æ³•(æœ‰é‡è¾¹)
Tarjanç®—æ³•æœ¬è´¨ä¸Šæ˜¯æ„å»ºä¸€ä¸ªdfsä¼˜å…ˆç”Ÿæˆæ ‘ï¼Œç„¶ååœ¨
æ ‘ä¸Šé€šè¿‡å¼•å…¥å›è¾¹çš„æ¦‚å¿µæ¥æ±‚è§£
************************************************
@æ¥å£: void Init (int rt)
@åŠŸèƒ½:åˆå§‹åŒ–é‚»æ¥è¡¨å’Œå…¶ä»–å˜é‡
@æ—¶é—´å¤æ‚åº¦: O (n ^ 2)
@rt: è¡¨ç¤ºdfsç”Ÿæˆæ ‘ä¸­çš„æ ¹(å¯ä»»æ„æŒ‡å®š)

@æ¥å£: void dfs (int u, int par)
@åŠŸèƒ½: dfsæ±‚è§£æ‰€æœ‰èŠ‚ç‚¹çš„dfnå’Œlowå€¼
@æ—¶é—´å¤æ‚åº¦: O (n ^ 2)
@u: å½“å‰èŠ‚ç‚¹
@par: å½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
************************************************/

#pragma comment(linker, "/STACK:102400000,102400000")
#include <set>
#include <bitset>
#include <list>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <string>
#include <vector>
#include <ios>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <utility>
#include <complex>
#include <numeric>
#include <functional>
#include <cmath>
#include <ctime>
#include <climits>
#include <cstdarg>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <cassert>
using namespace std;

#define CFF freopen ("aaa.txt", "r", stdin)
#define CPPFF ifstream cin ("aaa.txt")
#define	DB(ccc)	cout << #ccc << " = " << ccc << endl
#define PB push_back
#define MP(A, B) make_pair(A, B)

typedef long long LL;
typedef unsigned long long ULL;
typedef double DB;
typedef pair <int, int> PII;
typedef pair <int, bool> PIB;

const int INF = 0x7F7F7F7F;
const int MOD = 1e9 + 7;
const double EPS = 1e-10;
const double PI = 2 * acos (0.0);
const int maxn = 10000 + 66;

int vis[maxn], dfn[maxn], low[maxn], out[maxn*10];
int n, m, id, len;
map <PII, int> overedge;
vector <PII> edge[maxn*10];

void Init (int rt)
{
	overedge.clear ();
	for (int i = 0; i < maxn * 10; i++)
		edge[i].clear ();
	dfn[rt] = low[rt] = id = 1;
	memset (vis, 0, sizeof (vis));
	vis[rt] = 1;
	len = 0;
}

void dfs (int u, int par)
{
	for (int i = 0; i < edge[u].size (); i++)
	{
		int v = edge[u][i].first;
		if (!vis[v])
		{
			vis[v] = 1;
			dfn[v] = low[v] = ++id;
			dfs (v, u);
			low[u] = min (low[u], low[v]);
			if (low[v] > dfn[u] && overedge[PII(u,v)] == 1)//æœ‰é‡è¾¹æ—¶éœ€è¦ç‰¹åˆ¤ï¼Œæ­¤æ—¶(u,v)ä¹‹é—´æ²¡æœ‰å‰²è¾¹
				out[++len] = edge[u][i].second;
		}

		else if (v != par)
			low[u] = min (low[u], dfn[v]);
	}
}

int main()
{
    //CFF;
    //CPPFF;
	int t, flag = 1;
	scanf ("%d", &t);
	while (t--)
	{
		if (flag++ > 1) puts ("");
		scanf ("%d%d", &n, &m);

		Init (1);
		for (int i = 1; i <= m; i++)
		{
			int u, v;
			scanf ("%d%d", &u, &v);
			edge[u].push_back (PII (v, i));
			edge[v].push_back (PII (u, i));
			if (overedge.find (PII (u, v)) == overedge.end ())
				overedge[PII(u,v)] = overedge[PII(v,u)] = 1;

			else
				overedge[PII(u,v)]++, overedge[PII(v,u)]++;
		}

		dfs (1, -1);

		printf ("%d\n", len);
		sort (out + 1, out + 1 + len);
		for (int i = 1; i <= len; i++)
		{
			if (i == 1) printf ("%d", out[i]);
			else printf (" %d", out[i]);
		}
		if (len) puts ("");
	}
    return 0;
}
\end{lstlisting}
\subsection{æ±‚æ— å‘å›¾å‰²è¾¹+ç¼©ç‚¹(æ— é‡è¾¹)}
\begin{lstlisting}[language=C++]
/***********************************************
ä»¥POJ 3352ä¸ºä¾‹ Tarjanç®—æ³•(æ— é‡è¾¹)
Tarjanç®—æ³•æœ¬è´¨ä¸Šæ˜¯æ„å»ºä¸€ä¸ªdfsä¼˜å…ˆç”Ÿæˆæ ‘ï¼Œç„¶ååœ¨
æ ‘ä¸Šé€šè¿‡å¼•å…¥å›è¾¹çš„æ¦‚å¿µæ¥æ±‚è§£

æ³¨æ„ï¼š
è‹¥å›¾ä¸­æ²¡æœ‰é‡è¾¹ï¼Œåˆ™lowå€¼ç›¸åŒçš„é¡¶ç‚¹ä¸€å®šåœ¨ä¸€ä¸ªè¾¹é‡
è¿é€šåˆ†é‡ä¸­(å› ä¸ºæœ‰ç¯)ã€‚æ‰€ä»¥æ­¤æ—¶å¯ä»¥ä¸ä½¿ç”¨æ ˆæ¥æ‰¾ç‚¹
ï¼Œè€Œæ˜¯åŒé‡å¾ªç¯æšä¸¾æ‰¾é‚»æ¥é¡¶ç‚¹ï¼Œè‹¥ä¸¤ä¸ªé¡¶ç‚¹çš„lowä¸åŒ
ï¼Œåˆ™å®ƒä»¬å„è‡ªæ‰€åœ¨çš„â€œç¼©ç‚¹â€çš„åº¦æ•°è‡ªåŠ 1
************************************************
@æ¥å£: void Init (int rt)
@åŠŸèƒ½:åˆå§‹åŒ–é‚»æ¥è¡¨å’Œå…¶ä»–å˜é‡
@æ—¶é—´å¤æ‚åº¦: O (n ^ 2)
@rt: è¡¨ç¤ºdfsç”Ÿæˆæ ‘ä¸­çš„æ ¹(å¯ä»»æ„æŒ‡å®š)

@æ¥å£: void dfs (int u, int par)
@åŠŸèƒ½: dfsæ±‚è§£æ‰€æœ‰èŠ‚ç‚¹çš„dfnå’Œlowå€¼
@æ—¶é—´å¤æ‚åº¦: O (n ^ 2)
@u: å½“å‰èŠ‚ç‚¹
@par: å½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
************************************************/

#pragma comment(linker, "/STACK:102400000,102400000")
#include <set>
#include <bitset>
#include <list>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <string>
#include <vector>
#include <ios>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <utility>
#include <complex>
#include <numeric>
#include <functional>
#include <cmath>
#include <ctime>
#include <climits>
#include <cstdarg>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <cassert>
using namespace std;

#define CFF freopen ("aaa.txt", "r", stdin)
#define CPPFF ifstream cin ("aaa.txt")
#define	DB(ccc)	cout << #ccc << " = " << ccc << endl
#define PB push_back
#define MP(A, B) make_pair(A, B)

typedef long long LL;
typedef unsigned long long ULL;
typedef double DB;
typedef pair <int, int> PII;
typedef pair <int, bool> PIB;

const int INF = 0x7F7F7F7F;
const int MOD = 1e9 + 7;
const double EPS = 1e-10;
const double PI = 2 * acos (0.0);
const int maxn = 5000 + 6;

int dfn[maxn], low[maxn], vis[maxn];
int n, m, id;
stack <PII> sta;
vector <int> g[maxn];
set <PII> seta;
int parent[maxn], deg[maxn], part[maxn];

int UnFind (int val)
{
	if (parent[val] == val) return val;
	else return parent[val] = UnFind (parent[val]);
}

void Init (int rt)
{
	for (int i = 0; i < maxn; i++)
		parent[i] = i;
	
	for (int i = 0; i < maxn; i++)
		g[i].clear ();
	seta.clear ();
	dfn[rt] = low[rt] = id = 1;
	memset (vis, 0, sizeof (vis));
	memset (deg, 0, sizeof (deg));
	vis[rt] = 1;
	while (!sta.empty ()) sta.pop ();
}

void SS ()
{
	for (int u = 1; u <= n; u++)
		if (part[u])
		{
			for (int i = 0; i < g[u].size (); i++)
			{
				int v = g[u][i];
				if (part[v])
					parent[UnFind(v)] = UnFind (u);
			}
		}
}

void dfs (int u, int par)
{
	for (int i = 0; i < g[u].size (); i++)
	{
		int v = g[u][i];
		if (seta.find (PII (u, v)) == seta.end ())
		{
			seta.insert (PII (u, v));
			seta.insert (PII (v, u));
			sta.push (PII (u, v));
			if (!vis[v])
			{
				vis[v] = 1;
				dfn[v] = low[v] = ++id;
				dfs (v, u);
				low[u] = min (low[u], low[v]);
				if (low[v] > dfn[u])
				{
					memset (part, 0, sizeof (part));
					//bool is_have = false;
					while (!sta.empty ())
					{
						PII temp = sta.top (); sta.pop ();
						if ((temp.first == u && temp.second == v) || (temp.first == v && temp.second == u))
							break;
						part[temp.first] = part[temp.second] = 1;
						//printf (" %d-%d ", temp.first, temp.second);
						//is_have = true;
					}
					//if (is_have)
					//	puts ("");
					SS ();
				}
			}
			else if (v != par)
				low[u] = min (low[u], dfn[v]);	
		}
	}
}

int main()
{
    //CFF;
    //CPPFF;
	while (scanf ("%d%d", &n, &m) != EOF)
	{
		Init (1);
		for (int i = 1; i <= m; i++)
		{
			int u, v;
			scanf ("%d%d", &u, &v);
			g[u].push_back (v);
			g[v].push_back (u);
		}
		dfs (1, -1);

		seta.clear ();
		for (int u = 1; u <= n; u++)
			for (int i = 0; i < g[u].size (); i++)
			{
				int v = g[u][i];
				if (seta.find (PII (u, v)) != seta.end ()) continue;
				seta.insert (PII (u, v)), seta.insert (PII (v, u));
				if (UnFind (u) != UnFind (v))
					deg[UnFind(u)]++, deg[UnFind(v)]++;
			}

		int res = 0;
		for (int i = 1; i <= n; i++)
		{
			//cout << "i = " << i << " deg[i] = " << deg[i] << endl;
			if (deg[i] == 1) 
				res++;
		}

		printf ("%d\n", (res + 1) / 2);
	}
    return 0;
}
\end{lstlisting}
\subsection{æ±‚æ— å‘å›¾å‰²è¾¹+ç¼©ç‚¹(æœ‰é‡è¾¹)}
\begin{lstlisting}[language=C++]
/***********************************************
ä»¥POJ 3177ä¸ºä¾‹ Tarjanç®—æ³•(æœ‰é‡è¾¹)
Tarjanç®—æ³•æœ¬è´¨ä¸Šæ˜¯æ„å»ºä¸€ä¸ªdfsä¼˜å…ˆç”Ÿæˆæ ‘ï¼Œç„¶ååœ¨
æ ‘ä¸Šé€šè¿‡å¼•å…¥å›è¾¹çš„æ¦‚å¿µæ¥æ±‚è§£

æ³¨æ„ï¼š
è¿™ä¸ªç®—æ³•åŒæ ·é€‚ç”¨äºæ— é‡è¾¹çš„æƒ…å†µã€‚è¿™é‡Œæ²¡æœ‰ä½¿ç”¨å¹¶æŸ¥
é›†æ¥ç¼©ç‚¹ï¼Œè€Œæ˜¯ä½¿ç”¨åœ¨åŒä¸€ä¸ªè¾¹é‡è¿é€šåˆ†é‡ä¸­çš„ç‚¹çš„low
å€¼ç›¸åŒè¿™ä¸ªæ€§è´¨æ¥æ±‚è§£çš„
************************************************
@æ¥å£: void Init (int rt)
@åŠŸèƒ½:åˆå§‹åŒ–é‚»æ¥è¡¨å’Œå…¶ä»–å˜é‡
@æ—¶é—´å¤æ‚åº¦: O (n ^ 2)
@rt: è¡¨ç¤ºdfsç”Ÿæˆæ ‘ä¸­çš„æ ¹(å¯ä»»æ„æŒ‡å®š)

@æ¥å£: void dfs (int u, int par)
@åŠŸèƒ½: dfsæ±‚è§£æ‰€æœ‰èŠ‚ç‚¹çš„dfnå’Œlowå€¼
@æ—¶é—´å¤æ‚åº¦: O (n ^ 2)
@u: å½“å‰èŠ‚ç‚¹
@par: å½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
************************************************/

#pragma comment(linker, "/STACK:102400000,102400000")
#include <set>
#include <bitset>
#include <list>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <string>
#include <vector>
#include <ios>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <utility>
#include <complex>
#include <numeric>
#include <functional>
#include <cmath>
#include <ctime>
#include <climits>
#include <cstdarg>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <cassert>
using namespace std;

#define CFF freopen ("aaa.txt", "r", stdin)
#define CPPFF ifstream cin ("aaa.txt")
#define	DB(ccc)	cout << #ccc << " = " << ccc << endl
#define PB push_back
#define MP(A, B) make_pair(A, B)

typedef long long LL;
typedef unsigned long long ULL;
typedef double DB;
typedef pair <int, int> PII;
typedef pair <int, bool> PIB;

const int INF = 0x7F7F7F7F;
const int MOD = 1e9 + 7;
const double EPS = 1e-10;
const double PI = 2 * acos (0.0);
const int maxn = 5000 + 6;

int dfn[maxn], low[maxn], vis[maxn], deg[maxn];
int n, m, id;
vector <int> g[maxn];
set <PII> seta;

void Init (int rt)
{	
	for (int i = 0; i < maxn; i++)
		g[i].clear ();
	seta.clear ();
	dfn[rt] = low[rt] = id = 1;
	memset (vis, 0, sizeof (vis));
	memset (deg, 0, sizeof (deg));
	vis[rt] = 1;
}

void dfs (int u, int par)
{
	for (int i = 0; i < g[u].size (); i++)
	{
		int v = g[u][i];
		if (!vis[v])
		{
			vis[v] = 1;
			dfn[v] = low[v] = ++id;
			dfs (v, u);
			low[u] = min (low[u], low[v]);
		}
		else if (v != par)
			low[u] = min (low[u], dfn[v]);
	}
}

void SS ()
{
	for (int u = 1; u <= n; u++)
		for (int i = 0; i < g[u].size (); i++)
		{
			int v = g[u][i];
			if (low[u] != low[v])
				deg[low[u]]++;
		}
}

int main()
{
    CFF;
    //CPPFF;
	while (scanf ("%d%d", &n, &m) != EOF)
	{
		Init (1);
		for (int i = 1; i <= m; i++)
		{
			int u, v;
			scanf ("%d%d", &u, &v);
			if (seta.find (PII (u, v)) != seta.end ()) continue;
			seta.insert (PII (u, v)), seta.insert (PII (v, u));
			g[u].push_back (v);
			g[v].push_back (u);
		}

		dfs (1, -1);
		SS ();

		int res = 0;
		for (int i = 1; i <= n; i++)
			if (deg[i] == 1) 
				res++;

		printf ("%d\n", (res + 1) / 2);
	}
    return 0;
}
\end{lstlisting}
\subsection{æ±‚æœ‰å‘å›¾å¼ºè¿é€šåˆ†é‡(Tarjan)}
\begin{lstlisting}[language=C++]
/***********************************************
æ±‚è§£æœ‰å‘å›¾å¼ºè¿é€šåˆ†é‡çš„Tarjanç®—æ³•
å¤æ‚åº¦ä¸ºO (n + m)

Tarjanç®—æ³•æœ¬è´¨ä¸Šæ˜¯æ„å»ºä¸€ä¸ªdfsä¼˜å…ˆç”Ÿæˆæ ‘ï¼Œç„¶ååœ¨
æ ‘ä¸Šé€šè¿‡å¼•å…¥å›è¾¹çš„æ¦‚å¿µæ¥æ±‚è§£

æ±‚æ³•ï¼š
åœ¨è¿›è¡Œdfsæœç´¢æ—¶ï¼ŒæŠŠå½“å‰æœç´¢æ ‘ä¸­æœªå¤„ç†çš„é¡¶ç‚¹å‹å…¥
æ ˆä¸­ï¼Œå›æº¯æ—¶åˆ¤å®šã€‚å½“dfn[u] == low[u]æ—¶ï¼Œåˆ™ä»¥uä¸º
æ ¹çš„å­æ ‘ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹æ˜¯ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ã€‚é‡ç‚¹æ˜¯å¦‚ä½•
åˆ¤å®šä¸€ä¸ªè¾¹æ˜¯dfsç”Ÿæˆæ ‘çš„è¾¹ã€å›è¾¹è¿˜æ˜¯äº¤å‰è¾¹ã€‚æ–¹æ³•
æ˜¯è‹¥é¡¶ç‚¹uçš„é‚»æ¥ç‚¹vè¿˜æœªè®¿é—®ï¼Œåˆ™<u,v>æ˜¯ç”Ÿæˆæ ‘çš„è¾¹ã€‚
å¦åˆ™vå·²ç»è®¿é—®äº†ï¼Œä¸æ˜¯ç”Ÿæˆæ ‘çš„è¾¹äº†ã€‚æ¥ç€è‹¥é‚»æ¥ç‚¹v
è¿˜åœ¨æ ˆä¸­ï¼Œå³é¡¶ç‚¹uå’Œvåœ¨ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ä¸­ï¼Œvæ˜¯uçš„ç¥–
å…ˆï¼Œåˆ™<u,v>æ˜¯å›è¾¹ã€‚åä¹‹ï¼Œé‚»æ¥ç‚¹vä¸åœ¨æ ˆä¸­ï¼Œå³é¡¶ç‚¹
uå’Œvä¸åœ¨ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ä¸­ï¼Œåˆ™<u,v>æ˜¯äº¤å‰è¾¹
************************************************
@æ¥å£: void Init (int rt)
@åŠŸèƒ½:åˆå§‹åŒ–é‚»æ¥è¡¨
@æ—¶é—´å¤æ‚åº¦: O (n)

@æ¥å£: void dfs (int u)
@åŠŸèƒ½: dfsæ±‚è§£æ‰€æœ‰èŠ‚ç‚¹çš„dfnå’Œlowå€¼
@æ—¶é—´å¤æ‚åº¦: O (n + m)
@u: å½“å‰èŠ‚ç‚¹

@æ¥å£: void SS ()
@åŠŸèƒ½: æ±‚è§£ç»™å®šæœ‰å‘å›¾çš„å¼ºè¿é€šåˆ†é‡(åŸå›¾å¯ä»¥ä¸è¿é€š)
@æ—¶é—´å¤æ‚åº¦: O (n + m)
************************************************/

//åˆ†åˆ«è¡¨ç¤ºé¡¶ç‚¹çš„dfnå€¼ã€lowå€¼å’Œé¡¶ç‚¹æ‰€å±çš„å¼ºè¿é€šåˆ†é‡æ ‡å·
int dfn[maxn], low[maxn], belong[maxn];
bool instack[maxn];//è¡¨ç¤ºé¡¶ç‚¹æ˜¯å¦åœ¨æ ˆä¸­
stack <int> sta;
vector <int> g[maxn];//é‚»æ¥è¡¨å­˜å›¾
int n, m, id, tot;//åˆ†åˆ«è¡¨ç¤ºé¡¶ç‚¹æ•°ã€è¾¹æ•°ã€dfsä¼˜å…ˆç”Ÿæˆæ ‘çš„å…¨å±€æ ‡è®°å’Œå¼ºè¿é€šåˆ†é‡çš„ä¸ªæ•°

void Init ()
{
	for (int i = 0; i < maxn; i++)
		g[i].clear ();
}

void dfs (int u)
{
	dfn[u] = low[u] = ++id;
	sta.push (u);
	instack[u] = true;
	for (int i = 0; i < g[u].size (); i++)
	{
		int v = g[u][i];
		if (!dfn[v])
		{
			dfs (v);
			low[u] = min (low[u], low[v]);
		}
		else if (instack[v])
			low[u] = min (low[u], dfn[v]);
	}
	if (low[u] == dfn[u])
	{
		tot++;
		int tt;
		do
		{
			tt = sta.top (); sta.pop ();
			instack[tt] = false;
			belong[tt] = tot;
		} while (!sta.empty () && tt != u);
	}
}

void SS ()
{
	memset (dfn, 0, sizeof (dfn));
	memset (low, 0, sizeof (low));
	memset (instack, false, sizeof (instack));
	while (!sta.empty ()) sta.pop ();
	tot = id = 0;	
	for (int i = 1; i <= n; i++)
		if (!dfn[i])
			dfs (i);
}
\end{lstlisting}
\subsection{æ±‚æœ‰å‘å›¾å¼ºè¿é€šåˆ†é‡(ä»¥POJ1236ä¸ºä¾‹)}
\begin{lstlisting}[language=C++]
/***********************************************
POJ1236
é—®é¢˜1ï¼šæ±‚è§£åœ¨ä¸€ä¸ªæœ‰å‘å›¾ä¸­è‡³å°‘é€‰æ‹©å‡ ä¸ªé¡¶ç‚¹ï¼Œæ‰èƒ½åš
åˆ°ä»è¿™äº›ç‚¹å‡ºå‘ï¼Œå¯ä»¥åˆ°è¾¾å…¨éƒ¨é¡¶ç‚¹
é—®é¢˜2ï¼šæ±‚è§£åœ¨ä¸€ä¸ªæœ‰å‘å›¾ä¸­è‡³å°‘æ·»åŠ å‡ æ¡è¾¹ï¼Œæ‰èƒ½ä½¿å¾—
ä»ä»»ä½•ä¸€ä¸ªé¡¶ç‚¹å‡ºå‘ï¼Œå¯ä»¥åˆ°è¾¾å…¨éƒ¨é¡¶ç‚¹

æ˜“çŸ¥é—®é¢˜1çš„æ±‚è§£åªéœ€è¦æ‰¾ç¼©ç‚¹åå‡ºåº¦ä¸º0çš„ç‚¹å³å¯
å¯¹äºé—®é¢˜2ï¼Œåªè¦æ‰¾å‡ºåº¦ä¸º0çš„ç‚¹çš„ä¸ªæ•°å’Œå…¥åº¦ä¸º0çš„ä¸ªæ•°
çš„è¾ƒå¤§å€¼å³å¯ã€‚é¦–å…ˆæ˜¯è‹¥å›¾ä¸­å­˜åœ¨å‡ºåº¦ä¸º0çš„ç‚¹å’Œå…¥åº¦ä¸º
0çš„ç‚¹è¯ï¼Œè¿™ä¸ªå›¾ä¸€å®šä¸æ˜¯å¼ºè¿é€šå›¾ã€‚å³éœ€è¦æ¶ˆå»è¿™äº›ç‚¹
ï¼Œæ‰€ä»¥ä¼˜å…ˆè¿™äº›ç‚¹ä¹‹é—´è¿è¾¹ã€‚æ¯ä¸€æ¬¡ä»å‡ºåº¦ä¸º0çš„ç‚¹å‘å…¥
åº¦ä¸º0çš„ç‚¹è¿ä¸€æ¡è¾¹ï¼Œå°±ä¼šæ„å»ºå‡ºä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ï¼Œç›´åˆ°
æ‰€æœ‰å‡ºåº¦ä¸º0çš„ç‚¹åå…¥åº¦ä¸º0çš„ç‚¹éƒ½è¢«æ¶ˆå»ä¸ºæ­¢ã€‚æ³¨æ„å½“
åŸå›¾ä¸­åªæœ‰ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡æ—¶ï¼Œç»“æœéœ€è¦ç‰¹åˆ¤ä¸º0ï¼ï¼ï¼
************************************************/

#pragma comment(linker, "/STACK:102400000,102400000")
#include <set>
#include <bitset>
#include <list>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <string>
#include <vector>
#include <ios>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <utility>
#include <complex>
#include <numeric>
#include <functional>
#include <cmath>
#include <ctime>
#include <climits>
#include <cstdarg>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <cassert>
using namespace std;

#define CFF freopen ("aaa.txt", "r", stdin)
#define CPPFF ifstream cin ("aaa.txt")
#define	DB(ccc)	cout << #ccc << " = " << ccc << endl
#define PB push_back
#define MP(A, B) make_pair(A, B)

typedef long long LL;
typedef unsigned long long ULL;
typedef double DB;
typedef pair <int, int> PII;
typedef pair <int, bool> PIB;

const int INF = 0x7F7F7F7F;
const int MOD = 1e9 + 7;
const double EPS = 1e-10;
const double PI = 2 * acos (0.0);
const int maxn = 166 + 66;

int dfn[maxn], low[maxn], belong[maxn], indeg[maxn], outdeg[maxn];
int n, id, tot;
bool instack[maxn];
vector <int> g[maxn];
stack <int> sta;

void dfs (int u)
{
	dfn[u] = low[u] = ++id;
	sta.push (u);
	instack[u] = true;
	for (int i = 0; i < g[u].size (); i++)
	{
		int v = g[u][i];
		if (!dfn[v])
		{
			dfs (v);
			low[u] = min (low[u], low[v]);
		}
		else if (instack[v])
			low[u] = min (low[u], dfn[v]);
	}
	if (low[u] == dfn[u])
	{
		tot++;
		int tt;
		do
		{
			tt = sta.top (); sta.pop ();
			instack[tt] = false;
			belong[tt] = tot;
		} while (!sta.empty () && tt != u);
	}
}

void SS ()
{
	memset (dfn, 0, sizeof (dfn));
	memset (low, 0, sizeof (low));
	memset (instack, false, sizeof (instack));
	id = tot = 0;
	while (!sta.empty ()) sta.pop ();
	for (int i = 1; i <= n; i++)
		if (!dfn[i])
			dfs (i);
}

int main()
{
    //CFF;
    //CPPFF;
	while (scanf ("%d", &n) != EOF)
	{
		for (int i = 0; i < maxn; i++)
			g[i].clear ();
		for (int i = 1; i <= n; i++)
		{
			int u;
			while (scanf ("%d", &u) != EOF)
			{
				if (u == 0) break;
				g[i].push_back (u);
			}
		}
		SS ();
		set <PII> seta;
		memset (indeg, 0, sizeof (indeg));
		memset (outdeg, 0, sizeof (outdeg));
		for (int u = 1; u <= n; u++)
			for (int i = 0; i < g[u].size (); i++)
			{
				int v = g[u][i];
				if (belong[u] != belong[v] && seta.find (PII (belong[u], belong[v])) == seta.end ())
				{
					indeg[belong[v]]++;
					outdeg[belong[u]]++;
					seta.insert (PII (belong[u], belong[v]));
				}
			}

		int resa = 0, resb = 0;
		for (int i = 1; i <= tot; i++)
		{
			if (!indeg[i]) resa++;
			if (!outdeg[i]) resb++;
		}
		
		printf ("%d\n", resa);
		if (tot == 1) puts ("0");
		else printf ("%d\n", max (resa, resb));
	}
    return 0;
}
\end{lstlisting}
\subsection{æ±‚æœ‰å‘å›¾å¼ºè¿é€šåˆ†é‡(ä»¥POJ1904ä¸ºä¾‹)}
\begin{lstlisting}[language=C++]
/***********************************************
POJ1904
é—®é¢˜ï¼šä¸€ä¸ªå›½ç‹æœ‰nä¸ªç‹å­å’Œnä¸ªå¥³å­©ã€‚æ¯ä¸ªç‹å­éƒ½æœ‰è‡ªå·±
å–œæ¬¢çš„è‹¥å¹²ä¸ªå¥³å­©ï¼Œç°ç»™å®šä¸€ä¸ªåˆæ³•çš„å®Œå¤‡åŒ¹é…ï¼ˆä¹Ÿå°±æ˜¯
ä¸€ä¸ªç‹å­å¨¶å…¶ä¸­ä¸€ä¸ªè‡ªå·±å–œæ¬¢å¥³å­©ï¼‰ï¼Œæ±‚æ¯ä¸ªç‹å­å¯ä»¥é€‰
æ‹©å“ªäº›å¥³å­©å¯ä»¥è®©å‰©ä¸‹çš„æ¯ä¸ªç‹å­ä¾æ—§èƒ½å¤Ÿé€‰æ‹©åˆ°è‡ªå·±å–œ
æ¬¢çš„ä¸€ä¸ªå¥³å­©

é¦–å…ˆæœ€ç›´è§‚çš„æƒ³æ³•å°±æ˜¯æšä¸¾+äºŒåˆ†åŒ¹é…åˆ¤å®šã€‚ä½†æ˜¯ç‚¹æ•°né«˜
è¾¾2000ï¼Œè¾¹æ•°eé«˜è¾¾200000ï¼›æ‰€ä»¥æšä¸¾çš„å¤æ‚åº¦O (e + n)
 * O (n ^ 2) = O( n ^ 2 * (e + n))å¤ªå¤§äº†ï¼Œæ˜¾ç„¶è¶…æ—¶

å› ä¸ºé¢˜ç›®å·²ç»ç»™å®šäº†ä¸€ä¸ªå®Œå¤‡åŒ¹é…ï¼Œè€Œä¸Šè¿°ç®—æ³•è¿˜æ²¡æœ‰åˆ©
ç”¨è¿™ä¸ªå®Œå¤‡åŒ¹é…ã€‚è‹¥å·²ç»æœ‰äº†ä¸€ä¸ªå®Œå¤‡åŒ¹é…ï¼Œå‡å¦‚ç‹å­xi
å¯¹åº”å¥³å­©yiæ˜¯å®Œå¤‡åŒ¹é…ä¸­çš„ä¸€æ¡è¾¹ï¼Œé‚£ä¹ˆyiè‚¯å®šæ˜¯å¿…å®šå±
äºå¯é€‰é›†åˆçš„ã€‚å¯¹äºä¸æ˜¯yiçš„yjï¼Œå¦‚æœç‹å­å–œæ¬¢yjï¼Œé‚£ä¹ˆ
å‡è®¾æˆ‘ä»¬ç°åœ¨è®©ç‹å­é€‰æ‹©yjï¼Œç”±äºå¿…é¡»å½¢æˆä¸€ä¸ªå®Œå¤‡åŒ¹é…
ï¼Œå¦‚æœmatch[yj]==xj (match[yj]ä¿å­˜çš„æ˜¯ç»™å®šçš„å®Œå¤‡åŒ¹
é…ä¸­ä¸å¥³å­©yjåŒ¹é…çš„ç‹å­xj)ï¼Œé‚£ä¹ˆåªè¦èƒ½ä»xjå‡ºå‘æ‰¾åˆ°
ä¸€æ¡æ–°çš„å¢å¹¿è·¯å¾„ï¼Œåˆ™æˆ‘ä»¬çš„å‡è®¾å¯ä»¥æˆç«‹ã€‚è¿™ä¸ªä¼˜åŒ–çš„
æœ¬è´¨è¿˜æ˜¯åœ¨è¿›è¡ŒåŒ¹é…ï¼Œåªä¸è¿‡æˆ‘ä»¬æ²¡æœ‰é‡æ–°è¿›è¡Œæ–°çš„åŒ¹é…
ï¼Œè€Œæ˜¯å……åˆ†åˆ©ç”¨å·²ç»™å‡ºçš„åŒ¹é…ï¼Œä»…ä»…è¯•æ¢æ€§çš„å¯»æ‰¾ï¼Œçœ‹çœ‹
æ˜¯å¦å­˜åœ¨å¯è¡Œçš„å¢å¹¿è·¯ã€‚è¿™ä¸ªç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ï¼š
O((e + n) * n)ï¼Œå·²ç»ä¼˜åŒ–æ‰äº†1ç»´ï¼Œä½†æ˜¯åœ¨å•case2000ms
çš„é™åˆ¶ä¸‹è¿˜æ˜¯ä¼šæŒ‚æ‰çš„ã€‚

å¯ä»¥å‘ç°ï¼Œæˆ‘ä»¬åˆšæ‰è™½ç„¶ä¼˜åŒ–äº†ï¼Œä½†æ˜¯ç®—æ³•ä¾æ—§åšäº†ä¸€äº›
æ— ç”¨åŠŸï¼Œå¯¹äºæ¯æ¬¡æšä¸¾ï¼Œæˆ‘ä»¬åªå¸Œæœ›çŸ¥é“æ˜¯å¦å­˜åœ¨æ–°çš„å¢
å¹¿è·¯å¾„ï¼Œè€Œä¸Šé¢çš„ä¼˜åŒ–æ˜¾ç„¶å·²ç»æ‰¾å‡ºäº†å¯è¡Œå¢å¹¿é“¾ã€‚æˆ‘ä»¬
å¦‚ä½•æ‰èƒ½ä¸é€šè¿‡å¯»æ‰¾å¢å¹¿é“¾è€Œç›´æ¥ç¡®å®šæ˜¯å¦å­˜åœ¨å¢å¹¿é“¾å‘¢
ï¼Ÿå¯ä»¥çš„ã€‚è®©æˆ‘ä»¬å†æ¬¡å›åˆ°åˆå§‹çš„æƒ³æ³•ï¼Œå¦‚æœç»™å®šçš„å®Œå¤‡
åŒ¹é…ä¸­xi->yiï¼Œç°åœ¨æˆ‘ä»¬æƒ³è®©xiæŒ‡å‘yjã€‚å¦‚æœè®©xi->yjçš„
è¯ï¼Œé‚£ä¹ˆyiæ˜¾ç„¶å¯¹äºxiå·²ç»æ²¡ç”¨äº†ï¼Œåˆå› ä¸ºæœ€ç»ˆçš„åŒ¹é…å¿…
ç„¶æ˜¯ä¸€ä¸ªå®Œå¤‡åŒ¹é…ï¼Œæ‰€ä»¥å‡å¦‚å¯»æ‰¾åˆ°äº†å¢å¹¿é“¾ï¼Œé‚£ä¹ˆå¢å¹¿
é“¾çš„æœ€åä¸€æ¡è¾¹æ‰€æŒ‡å‘çš„èŠ‚ç‚¹å¿…ç„¶æ˜¯yiã€‚å‡å¦‚æˆ‘ä»¬ç”±yiå‘
xiå†è¿ä¸€æ¡è¾¹ä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ï¼Ÿå¾ˆæ˜æ˜¾ï¼Œå½¢æˆäº†ä¸€ä¸ªç¯ï¼ä¹Ÿ
å°±æ˜¯è¯´ï¼Œå½¢æˆäº†ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ã€‚æ‰€ä»¥è¯´ï¼Œå¦‚æœxiå¯ä»¥é€‰
æ‹©yjï¼Œé‚£ä¹ˆxiå’Œyjå¿…ç„¶å±äºåŒä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ã€‚æ‰€ä»¥æ­¤é¢˜
å¯ç”¨å¼ºè¿é€šåˆ†é‡æ¥æ±‚è§£
************************************************/

#pragma comment(linker, "/STACK:102400000,102400000")
#include <set>
#include <bitset>
#include <list>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <string>
#include <vector>
#include <ios>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <utility>
#include <complex>
#include <numeric>
#include <functional>
#include <cmath>
#include <ctime>
#include <climits>
#include <cstdarg>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <cassert>
using namespace std;

#define CFF freopen ("aaa.txt", "r", stdin)
#define CPPFF ifstream cin ("aaa.txt")
#define	DB(ccc)	cout << #ccc << " = " << ccc << endl
#define PB push_back
#define MP(A, B) make_pair(A, B)

typedef long long LL;
typedef unsigned long long ULL;
typedef double DB;
typedef pair <int, int> PII;
typedef pair <int, bool> PIB;

const int INF = 0x7F7F7F7F;
const int MOD = 1e9 + 7;
const double EPS = 1e-10;
const double PI = 2 * acos (0.0);
const int maxn = 2 * 2000 + 66;

int dfn[maxn], low[maxn], belong[maxn];
int n, id, tot;
bool instack[maxn], gg[maxn][maxn];
vector <int> g[maxn];
stack <int> sta;

void dfs (int u)
{
	dfn[u] = low[u] = ++id;
	sta.push (u);
	instack[u] = true;
	for (int i = 0; i < g[u].size (); i++)
	{
		int v = g[u][i];
		if (!dfn[v])
		{
			dfs (v);
			low[u] = min (low[u], low[v]);
		}
		else if (instack[v])
			low[u] = min (low[u], dfn[v]);
	}

	if (low[u] == dfn[u])
	{
		tot++;
		int tt;
		do
		{
			tt = sta.top (); sta.pop ();
			instack[tt] = false;
			belong[tt] = tot;
		} while (!sta.empty () && tt != u);
	}
}

void SS ()
{
	memset (dfn, 0, sizeof (dfn));
	memset (low, 0, sizeof (low));
	memset (instack, false, sizeof (instack));
	id = tot = 0;
	while (!sta.empty ()) sta.pop ();
	for (int i = 1; i <= n; i++)
		if (!dfn[i])
			dfs (i);
}

int main()
{
    //CFF;
    //CPPFF;
	while (scanf ("%d", &n) != EOF)
	{
		for (int i = 0; i < maxn; i++)
			g[i].clear ();
		memset (gg, false, sizeof (gg));

		for (int i = 1; i <= n; i++)
		{
			int num;
			scanf ("%d", &num);
			for (int j = 1; j <= num; j++)
			{
				int u;
				scanf ("%d", &u);
				g[i].push_back (n + u);
				gg[i][u] = true;
			}
		}
		
		for (int i = 1; i <= n; i++)
		{
			int u;
			scanf ("%d", &u);
			g[n+u].push_back (i);
		}

		SS ();
		vector <int> temp;
		for (int i = 1; i <= n; i++)
		{
			temp.clear ();
			for (int j = n + 1; j <= 2 * n; j++)
				if (gg[i][j-n] && belong[i] == belong[j])
					temp.push_back (j - n);
			sort (temp.begin (), temp.end ());
			printf ("%d", temp.size ());
			for (int j = 0; j < temp.size (); j++)
				printf (" %d", temp[j]);
			puts ("");
		}
	}
    return 0;
}
\end{lstlisting}
\subsection{æ±‚æœ‰å‘å›¾å¼ºè¿é€šåˆ†é‡(ä»¥POJ2762ä¸ºä¾‹)}
\begin{lstlisting}[language=C++]
/***********************************************
POJ2762
é—®é¢˜ï¼šåˆ¤å®šæ‰€ç»™çš„ä¸ªæœ‰å‘å›¾æ˜¯å¦æ˜¯å•è¿é€šçš„

æ±‚è§£ï¼šæ˜“çŸ¥åŒä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ä¸­çš„ç‚¹éƒ½æ˜¯å•è¿é€šçš„ï¼Œæ‰€ä»¥
å¯ä»¥ç¼©ç‚¹ã€‚å¯¹ç¼©ç‚¹åçš„å›¾è¿›è¡Œæ‹“æ‰‘æ’åºã€‚è‹¥æ‹“æ‰‘åºåˆ—æ‰€æœ‰
ç›¸é‚»çš„ç‚¹ä¹‹é—´é‚»æ¥ï¼Œåˆ™æ‰€ç»™çš„æœ‰å‘å›¾æ˜¯å•è¿é€šçš„ï¼Œå¦åˆ™ä¸
æ˜¯ã€‚è¿™æ˜¯è‡ªå·±ç®€å•ç”»ç”»å›¾å°±å‡ºæ¥äº†
************************************************/

#pragma comment(linker, "/STACK:102400000,102400000")
#include <set>
#include <bitset>
#include <list>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <string>
#include <vector>
#include <ios>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <utility>
#include <complex>
#include <numeric>
#include <functional>
#include <cmath>
#include <ctime>
#include <climits>
#include <cstdarg>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <cassert>
using namespace std;

#define CFF freopen ("aaa.txt", "r", stdin)
#define CPPFF ifstream cin ("aaa.txt")
#define	DB(ccc)	cout << #ccc << " = " << ccc << endl
#define PB push_back
#define MP(A, B) make_pair(A, B)

typedef long long LL;
typedef unsigned long long ULL;
typedef double DB;
typedef pair <int, int> PII;
typedef pair <int, bool> PIB;

const int INF = 0x7F7F7F7F;
const int MOD = 1e9 + 7;
const double EPS = 1e-10;
const double PI = 2 * acos (0.0);
const int maxn = 1000 + 66;

int dfn[maxn], low[maxn], belong[maxn];
bool instack[maxn];
stack <int> sta;
vector <int> g[maxn];
int n, m, id, tot;
int gg[maxn][maxn], indeg[maxn], topo[maxn];

void Init ()
{
	for (int i = 0; i < maxn; i++)
		g[i].clear ();
}

void dfs (int u)
{
	dfn[u] = low[u] = ++id;
	sta.push (u);
	instack[u] = true;
	for (int i = 0; i < g[u].size (); i++)
	{
		int v = g[u][i];
		if (!dfn[v])
		{
			dfs (v);
			low[u] = min (low[u], low[v]);
		}
		else if (instack[v])
			low[u] = min (low[u], dfn[v]);
	}
	if (low[u] == dfn[u])
	{
		tot++;
		int tt;
		do
		{
			tt = sta.top (); sta.pop ();
			instack[tt] = false;
			belong[tt] = tot;
		} while (!sta.empty () && tt != u);
	}
}

void SS ()
{
	memset (dfn, 0, sizeof (dfn));
	memset (low, 0, sizeof (low));
	memset (instack, false, sizeof (instack));
	while (!sta.empty ()) sta.pop ();
	tot = id = 0;	
	for (int i = 1; i <= n; i++)
		if (!dfn[i])
			dfs (i);
}

int main()
{
    //CFF;
    //CPPFF;
	int t;
	scanf ("%d", &t);
	while (t--)
	{
		Init ();
		scanf ("%d%d", &n, &m);
		for (int i = 1; i <= m; i++)
		{
			int u, v;
			scanf ("%d%d", &u, &v);
			g[u].push_back (v);
		}
		SS ();
		memset (gg, 0, sizeof (gg));
		memset (indeg, 0, sizeof (indeg));
		for (int u = 1; u <= n; u++)
			for (int i = 0; i < g[u].size (); i++)
			{
				int v = g[u][i];
				if (belong[u] != belong[v])
				{
					gg[belong[u]][belong[v]] = 1;
					indeg[belong[v]]++;
				}
			}
	
		queue <int> qua;
		for (int i = 1; i <= tot; i++)
			if (!indeg[i])
				qua.push (i);

		int len = 0;
		while (!qua.empty ())
		{
			int u = qua.front (); qua.pop ();
			topo[++len] = u;
			for (int v = 1; v <= tot; v++)
				if (u != v && gg[u][v])
				{
					indeg[v]--;
					if (!indeg[v])
						qua.push (v);
				}
		}
		
		bool is_valid = true;
		for (int i = 1; i <= tot - 1; i++)
			if (!gg[topo[i]][topo[i+1]])	
			{
				is_valid = false;
				break;
			}
		if (is_valid) puts ("Yes");
		else puts ("No");
	}
    return 0;
}
\end{lstlisting}
\subsection{æ±‚æ··åˆå›¾æ¬§æ‹‰å›è·¯}
\begin{lstlisting}[language=C++]
/***********************************************
POJ1637
é—®é¢˜ï¼šå¯¹äºæ— å‘è¾¹å’Œæœ‰å‘è¾¹ç»„æˆçš„æ··åˆå›¾ï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨
æ¬§æ‹‰å›è·¯

æ±‚è§£
å…¶å®é—®é¢˜çš„éš¾ç‚¹åœ¨äºå›¾ä¸­çš„æ— å‘è¾¹ï¼Œéœ€è¦å¯¹æ‰€æœ‰çš„æ— å‘è¾¹
å®šå‘(æŒ‡å®šä¸€ä¸ªæ–¹å‘ï¼Œä½¿ä¹‹å˜ä¸ºæœ‰å‘è¾¹)ï¼Œä½¿æ•´ä¸ªå›¾å˜æˆä¸€
ä¸ªæœ‰å‘æ¬§æ‹‰å›¾(æˆ–æœ‰å‘åŠæ¬§æ‹‰å›¾)ã€‚è‹¥å­˜åœ¨ä¸€ä¸ªå®šå‘æ»¡è¶³æ­¤
æ¡ä»¶ï¼Œåˆ™åŸå›¾æ˜¯æ¬§æ‹‰å›¾(æˆ–åŠæ¬§æ‹‰å›¾)å¦åˆ™ä¸æ˜¯ã€‚å…³é”®å°±æ˜¯
å¦‚ä½•å®šå‘ï¼Ÿ

é¦–å…ˆç»™åŸå›¾ä¸­çš„æ¯æ¡æ— å‘è¾¹éšä¾¿æŒ‡å®šä¸€ä¸ªæ–¹å‘(ç§°ä¸ºåˆå§‹å®š
å‘)ï¼Œå°†åŸå›¾æ”¹ä¸ºæœ‰å‘å›¾G'ã€‚ç„¶åçš„ä»»åŠ¡å°±æ˜¯æ”¹å˜G'ä¸­æŸäº›
è¾¹çš„æ–¹å‘(å½“ç„¶æ˜¯æ— å‘è¾¹è½¬åŒ–æ¥çš„ï¼ŒåŸæ··åˆå›¾ä¸­çš„æœ‰å‘è¾¹ä¸
èƒ½åŠ¨)ï¼Œä½¿å…¶æ»¡è¶³æ¯ä¸ªç‚¹çš„å…¥åº¦ç­‰äºå‡ºåº¦
è®¾D[i]ä¸ºG'ä¸­(ç‚¹içš„å‡ºåº¦ - ç‚¹içš„å…¥åº¦)ã€‚å¯ä»¥å‘ç°ï¼Œåœ¨æ”¹
å˜G'ä¸­è¾¹çš„æ–¹å‘çš„è¿‡ç¨‹ä¸­ï¼Œä»»ä½•ç‚¹çš„Då€¼çš„å¥‡å¶æ€§éƒ½ä¸ä¼šå‘
ç”Ÿæ”¹å˜(è®¾å°†è¾¹<i, j>æ”¹ä¸º<j, i>ï¼Œåˆ™iå…¥åº¦åŠ 1å‡ºåº¦å‡1ï¼Œj
å…¥åº¦å‡1å‡ºåº¦åŠ 1ï¼Œä¸¤è€…ä¹‹å·®åŠ 2æˆ–å‡2ï¼Œå¥‡å¶æ€§ä¸å˜)ï¼è€Œæœ€
ç»ˆè¦æ±‚çš„æ˜¯æ¯ä¸ªç‚¹çš„å…¥åº¦ç­‰äºå‡ºåº¦ï¼Œå³æ¯ä¸ªç‚¹çš„Då€¼éƒ½ä¸º0ï¼Œ
æ˜¯å¶æ•°ï¼Œæ•…å¯å¾—ï¼šè‹¥åˆå§‹å®šå‘å¾—åˆ°çš„G'ä¸­ä»»æ„ä¸€ä¸ªç‚¹çš„Då€¼
æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆåŸå›¾ä¸­ä¸€å®šä¸å­˜åœ¨æ¬§æ‹‰ç¯ï¼

è‹¥åˆå§‹Då€¼éƒ½æ˜¯å¶æ•°ï¼Œåˆ™å°†G'æ”¹è£…æˆç½‘ç»œï¼šè®¾ç«‹æºç‚¹Så’Œæ±‡ç‚¹
Tï¼Œå¯¹äºæ¯ä¸ªD[i]>0çš„ç‚¹iï¼Œè¿è¾¹<S, i>ï¼Œå®¹é‡ä¸ºD[i]/2ï¼›å¯¹
äºæ¯ä¸ªD[j]<0çš„ç‚¹jï¼Œè¿è¾¹<j, T>ï¼Œå®¹é‡ä¸º-D[j]/2ï¼›G'ä¸­çš„
æ¯æ¡è¾¹åœ¨ç½‘ç»œä¸­ä»ä¿ç•™ï¼Œå®¹é‡ä¸º1(è¡¨ç¤ºè¯¥è¾¹æœ€å¤šåªèƒ½è¢«æ”¹å˜
æ–¹å‘ä¸€æ¬¡)ã€‚æ±‚è¿™ä¸ªç½‘ç»œçš„æœ€å¤§æµï¼Œè‹¥Så¼•å‡ºçš„æ‰€æœ‰è¾¹å‡æ»¡æµ
ï¼Œåˆ™åŸæ··åˆå›¾æ˜¯æ¬§æ‹‰å›¾ï¼Œå°†ç½‘ç»œä¸­æ‰€æœ‰æµé‡ä¸º1çš„ä¸­é—´è¾¹(å°±
æ˜¯ä¸ä¸Sæˆ–Tå…³è”çš„è¾¹)åœ¨G'ä¸­æ”¹å˜æ–¹å‘ï¼Œå½¢æˆçš„æ–°å›¾G''ä¸€å®š
æ˜¯æœ‰å‘æ¬§æ‹‰å›¾ï¼›è‹¥Så¼•å‡ºçš„è¾¹ä¸­æœ‰çš„æ²¡æœ‰æ»¡æµï¼Œåˆ™åŸæ··åˆå›¾
ä¸æ˜¯æ¬§æ‹‰å›¾ã€‚

ä¸ºä»€ä¹ˆèƒ½è¿™æ ·å»ºå›¾ï¼Ÿ
è€ƒè™‘ç½‘ç»œä¸­çš„ä¸€æ¡å¢å¹¿è·¯å¾„S-->i-->...-->j-->Tï¼Œå°†è¿™æ¡ä»
iåˆ°jçš„è·¯å¾„åœ¨G'ä¸­å…¨éƒ¨åå‘ï¼Œåˆ™içš„å…¥åº¦åŠ 1å‡ºåº¦å‡1ï¼Œjçš„å…¥åº¦
å‡1å‡ºåº¦åŠ 1ï¼Œè·¯å¾„ä¸­å…¶å®ƒç‚¹çš„å…¥åº¦å‡ºåº¦å‡ä¸å˜ã€‚è€Œiæ˜¯å’ŒSç›¸è¿
çš„ï¼Œå› æ­¤åˆå§‹D[i]>0ï¼Œå³içš„å‡ºåº¦å¤§äºå…¥åº¦ï¼Œæ•…è¿™æ ·åå‘ä¹‹å
D[i]å‡å°‘2ï¼›åŒç†ï¼Œjæ˜¯å’ŒTç›¸è¿çš„ï¼Œè¿™æ ·åå‘ä¹‹åD[j]å¢åŠ 2ã€‚
å› æ­¤ï¼Œè‹¥æœ€å¤§æµä¸­è¾¹<S, i>æ»¡æµ(æµé‡ä¸ºåˆå§‹D[i]/2)ï¼Œæ­¤æ—¶
D[i]å€¼å°±å˜æˆäº†0ï¼Œä¹Ÿå°±æ˜¯içš„å…¥åº¦ç­‰äºå‡ºåº¦ã€‚å› æ­¤åªè¦ä½¿æ‰€
æœ‰Så¼•å‡ºçš„è¾¹å…¨éƒ¨æ»¡æµï¼Œæ‰€æœ‰åˆå§‹Då€¼>0çš„ç‚¹çš„Då€¼å°†ç­‰äº0ï¼Œ
åˆå› ä¸ºå°†è¾¹å˜å‘åæ‰€æœ‰ç‚¹çš„Då€¼ä¹‹å’Œä¸å˜ï¼Œæ‰€æœ‰åˆå§‹Då€¼å°äº0
çš„ç‚¹çš„Då€¼ä¹Ÿå°†ç­‰äº0ï¼Œè€Œåˆå§‹Då€¼ç­‰äº0çš„Dç‚¹æ—¢ä¸ä¸Sç›¸è¿ä¹Ÿä¸
ä¸Tç›¸è¿ï¼Œæ‰€ä»¥å®ƒä»¬æ˜¯ç½‘ç»œä¸­çš„ä¸­é—´ç‚¹ï¼Œè€Œä¸­é—´ç‚¹çš„æµå…¥é‡ç­‰
äºæµå‡ºé‡ï¼Œæ•…å®ƒä»¬çš„å…¥åº¦å’Œå‡ºåº¦ä¸€ç›´ä¸å˜ï¼Œå³Då€¼ä¸€ç›´ä¸º0ã€‚å› 
æ­¤ï¼Œæ•´ä¸ªå›¾G'æˆä¸ºæ¬§æ‹‰å›¾

æ‰©å±•é—®é¢˜ï¼šæ¬§æ‹‰è·¯å¾„çš„åˆ¤å®š
æ±‚è§£
é¦–å…ˆå¯ä»¥æƒ³åˆ°çš„æ˜¯æšä¸¾æ¬§æ‹‰è·¯å¾„çš„èµ·ç‚¹iå’Œç»ˆç‚¹jï¼Œç„¶ååœ¨
å›¾ä¸­æ·»åŠ è¾¹<j, i>ï¼Œå†æ±‚å›¾ä¸­æ˜¯å¦æœ‰æ¬§æ‹‰å›è·¯å³å¯ã€‚ä½†æ˜¯
ï¼Œè¯¥ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦è¾¾åˆ°äº†O(M * æœ€å¤§æµçš„æ—¶é—´)ï¼Œéœ€
è¦ä¼˜åŒ–
å‰é¢å·²ç»è¯´è¿‡ï¼Œåœ¨å°†è¾¹å˜å‘çš„è¿‡ç¨‹ä¸­ä»»ä½•ç‚¹çš„Då€¼çš„å¥‡å¶
æ€§éƒ½ä¸ä¼šæ”¹å˜ï¼Œè€Œä¸€ä¸ªæœ‰å‘å›¾æœ‰æ¬§æ‹‰è·¯å¾„çš„å……è¦æ¡ä»¶æ˜¯åŸº
å›¾è¿é€šä¸”æœ‰ä¸”åªæœ‰ä¸€ä¸ªç‚¹çš„å…¥åº¦æ¯”å‡ºåº¦å°‘1(ä½œä¸ºæ¬§æ‹‰è·¯å¾„
çš„èµ·ç‚¹)ï¼Œæœ‰ä¸”åªæœ‰ä¸€ä¸ªç‚¹çš„å…¥åº¦æ¯”å‡ºåº¦å¤š1(ä½œä¸ºç»ˆç‚¹)ï¼Œ
å…¶ä½™ç‚¹çš„å…¥åº¦ç­‰äºå‡ºåº¦ã€‚è¿™å°±è¯´æ˜ï¼Œå…ˆæŠŠå›¾ä¸­çš„æ— å‘è¾¹éš
ä¾¿å®šå‘ï¼Œç„¶åæ±‚æ¯ä¸ªç‚¹çš„Då€¼ï¼Œè‹¥æœ‰ä¸”åªæœ‰ä¸¤ä¸ªç‚¹çš„åˆå§‹D
å€¼ä¸ºå¥‡æ•°ï¼Œå…¶ä½™çš„ç‚¹åˆå§‹Då€¼éƒ½ä¸ºå¶æ•°ï¼Œåˆ™æœ‰å¯èƒ½å­˜åœ¨æ¬§æ‹‰
è·¯å¾„(å¦åˆ™ä¸å¯èƒ½å­˜åœ¨)ã€‚è¿›ä¸€æ­¥ï¼Œæ£€æŸ¥è¿™ä¸¤ä¸ªåˆå§‹Då€¼ä¸ºå¥‡
æ•°çš„ç‚¹ï¼Œè®¾ä¸ºç‚¹iå’Œç‚¹jï¼Œè‹¥æœ‰D[i]>0ä¸”D[j]<0ï¼Œåˆ™iä½œèµ·ç‚¹
jä½œç»ˆç‚¹(å¦åˆ™è‹¥D[i]ä¸D[j]åŒå·åˆ™ä¸å­˜åœ¨æ¬§æ‹‰è·¯å¾„)ï¼Œè¿è¾¹
<j, i>ï¼Œæ±‚æ˜¯å¦å­˜åœ¨æ¬§æ‹‰ç¯å³å¯(å°†æ±‚å‡ºçš„æ¬§æ‹‰ç¯ä¸­åˆ å»è¾¹
<j, i>å³å¯)ã€‚è¿™æ ·åªéœ€æ±‚ä¸€æ¬¡æœ€å¤§æµ
************************************************/

#pragma comment(linker, "/STACK:102400000,102400000")
#include <set>
#include <bitset>
#include <list>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <string>
#include <vector>
#include <ios>
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <utility>
#include <complex>
#include <numeric>
#include <functional>
#include <cmath>
#include <ctime>
#include <climits>
#include <cstdarg>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <cassert>
using namespace std;

#define CFF freopen ("aaa.txt", "r", stdin)
#define CPPFF ifstream cin ("aaa.txt")
#define	DB(ccc)	cout << #ccc << " = " << ccc << endl
#define PB push_back
#define MP(A, B) make_pair(A, B)

typedef long long LL;
typedef unsigned long long ULL;
typedef double DB;
typedef pair <int, int> PII;
typedef pair <int, bool> PIB;

const int INF = 0x7F7F7F7F;
const int MOD = 1e9 + 7;
const double EPS = 1e-10;
const double PI = 2 * acos (0.0);
const int maxn = 3000 + 66;

struct Node
{
	int to, nxt, c, f;	
};

Node edge[maxn];
int head[maxn], edgelen;
int dep[maxn], cnt[maxn], cur[maxn];

void Init ()
{
	memset (head, -1, sizeof (head));
	memset (edge, -1, sizeof (edge));
	edgelen = 0;
}

void AddEdge (int u, int v, int w, int rw = 0)
{
	edge[edgelen].to = v, edge[edgelen].c = w, edge[edgelen].f = 0;
	edge[edgelen].nxt = head[u], head[u] = edgelen++;
	edge[edgelen].to = u, edge[edgelen].c = rw, edge[edgelen].f = 0;
	edge[edgelen].nxt = head[v], head[v] = edgelen++;
}

void Bfs (int s, int e)
{
	memset (dep, -1, sizeof (dep));
	memset (cnt, 0, sizeof (cnt));
	dep[e] = 0;
	cnt[dep[e]]++;
	queue <int> qu;
	qu.push (e);
	while (!qu.empty ())
	{
		int u = qu.front (); qu.pop ();
		for (int i = head[u]; i != -1; i = edge[i].nxt)
		{
			int v = edge[i].to;
			if (dep[v] != -1) continue;
			qu.push (v);
			dep[v] = dep[u] + 1;
			cnt[dep[v]]++;
		}
	}
}

int sta[maxn];

int MaxFlow (int s, int e, int n)
{
	Bfs (s, e);
	int res = 0, top = 0, u = s;
	memcpy (cur, head, sizeof (head));
	while (dep[s] < n)
	{
		if (u == e)
		{
			int minval = INF, minval_pos = -1;
			for (int i = 0; i < top; i++)
				if (minval > edge[sta[i]].c - edge[sta[i]].f)
				{
					minval = edge[sta[i]].c - edge[sta[i]].f;
					minval_pos = i;
				}
			for (int i = 0; i < top; i++)
			{
				edge[sta[i]].f += minval;
				edge[sta[i]^1].f -= minval;
			}
			res += minval;
			top = minval_pos;
			u = edge[sta[top]^1].to;
		}
		else
		{
			bool is_have = false;
			for (int i = cur[u]; i != -1; i = edge[i].nxt)
			{
				int v = edge[i].to;
				if (edge[i].c - edge[i].f && dep[v] + 1 == dep[u])
				{
					cur[u] = i;
					sta[top++] = cur[u];
					u = v;
					is_have = true;
					break;
				}
			}
			if (is_have) continue;
			int minval = n;
			for (int i = head[u]; i != -1; i = edge[i].nxt)
				if (edge[i].c - edge[i].f && dep[edge[i].to] < minval)
				{
					minval = dep[edge[i].to];
					cur[u] = i;
				}
			cnt[dep[u]]--;
			if (!cnt[dep[u]]) return res;
			dep[u] = minval + 1;
			cnt[dep[u]]++;
			if (u != s) u= edge[sta[--top]^1].to;
		}
	}
	return res;
}

int indeg[maxn], outdeg[maxn];
int n, m;

void SS ()
{
	bool is_have = true;
	int full = 0;
	for (int i = 1; i <= n; i++)
	{
		if (abs (indeg[i] - outdeg[i]) & 1)
		{
			is_have = false;
			break;
		}
		if (indeg[i] > outdeg[i])
		{
			AddEdge (i, n + 1, (indeg[i] - outdeg[i]) / 2);
			full += (indeg[i] - outdeg[i]) / 2;		
		}
		else if (indeg[i] < outdeg[i])
			AddEdge (0, i, (outdeg[i] - indeg[i]) / 2);
	}

	if (!is_have) puts ("impossible");
	else
	{
		if (MaxFlow (0, n + 1, n + 2) == full) puts ("possible");
		else puts ("impossible");
	}
}

int main()
{
    //CFF;
    //CPPFF;
	int t;
	scanf ("%d", &t);
	while (t--)
	{
		Init ();
		memset (indeg, 0, sizeof (indeg));
		memset (outdeg, 0, sizeof (outdeg));

		scanf ("%d%d", &n, &m);
		for (int i = 1; i <= m; i++)
		{
			int u, v, w;
			scanf ("%d%d%d", &u, &v, &w);
			outdeg[u]++, indeg[v]++;
			if (!w) AddEdge (u, v, 1);			
		}
		SS ();
	}
    return 0;
}
\end{lstlisting}
